---
title: "Risk sharing with limited commitoment and storage"
bibliography: references.bib
format:
  html:
    toc: true
    html-math-method: katex
---

# Global settings

```{r}
pacman::p_load(
  tidyverse,
  nleqslv
)
```


```{r}
set.seed(123)

numStates <- 3
numRelativeParetoWeights <- 201
numHouseholds <- 2
beta <- 0.8
sigma <- 1

incomeGridPointsHH1 <- c(0.353, 0.5, 0.647)
incomeGridPointsHH2 <- 1 - incomeGridPointsHH1
aggregateIncome <- 1
aggregateIncomeGridPoints <- incomeGridPointsHH1 + incomeGridPointsHH2

incomeTransitionProbVec <- rep(1 / 3, 3)
incomeTransitionMatrix <- matrix(1 / 3, nrow = 3, ncol = 3)

returnOnStorage <- 0.1

```

```{r}
calculateUtility <- function(cons, sigma) {
  if (sigma != 1) {
    utility = (cons^(1 - sigma) - 1) / (1 - sigma)
  } else if (sigma == 1) {
    utility = log(cons)
  }
  return(utility)
}
calculateMarginalUtility <- function(cons, sigma) cons^(- sigma)

```

Since $b' > y + (1 + r) b$, it is not necessary to consider a storage $b$ with $y + (1 + r) b > b_{max}$, where $b_{max}$ is the max of the storage grid.

```{r}
storageGridPoints <- seq(0, sqrt(max(incomeGridPointsHH1) * 5), by = 1e-2)^2
# storageGridPoints <- storageGridPoints[
#   (1 + (1 + returnOnStorage) * storageGridPoints < max(storageGridPoints))
#   ]
numStorageGridPoints <- length(storageGridPoints)

```

```{r}
minRelativeParetoWeight <- 1 / max(incomeGridPointsHH1) - 1
maxRelativeParetoWeight <- 1 / minRelativeParetoWeight
# relativeParetoWeightsGridPoints <- seq(
#   minRelativeParetoWeight, maxRelativeParetoWeight,
#   length.out = numRelativeParetoWeights
# )
relativeParetoWeightsGridPoints <- c(
  seq(
    minRelativeParetoWeight, 1,
    by = (1 - minRelativeParetoWeight) / floor(numRelativeParetoWeights / 2)
  ),
  rev(1 / seq(
    minRelativeParetoWeight, 1,
    by = (1 - minRelativeParetoWeight) / floor(numRelativeParetoWeights / 2)
  )[1:floor(numRelativeParetoWeights / 2)])
)

```


### Value of autarky with storage

The expected lifetime utility of an agent $i$ under autarky with storage, at a state $s$ with private savings $b$, is
$$
  V_i^{aut}(s, b) = \max_{b' \ge 0} \left\{ u(y_i^s + (1 + r) b - b') + \beta \sum_{j} \pi^j V_i^{aut} (y^j, b') \right\}.
$$
The optimality condition, that is, the (individual) Euler equation, is
$$
  u'(c(s, b)) \ge (1 + r) \beta \sum_j \pi^j c(j, b'(s, b)),
$$
where the equality holds if $\beta'(s, b) > 0$.
Note that $b'(s, b) = y_i^s + (1 + r) b - c(s, b)$.
I use the policy function iteration method to calculate $c(s, b)$.

What we are interested in is $U_i^{aut} \equiv V_i^{aut}(s, 0)$, that is, the autarky value when there is no private saving, since this is the state households consider in participation constraints.

```{r}

calculateEulerEquationDiffAutarky <- function(
    consumption,
    income,
    storage,
    beta,
    sigma,
    returnOnStorage,
    incomeProb,
    storageGridPoints,
    consumptionAutarkyMatrix
) {
  
  interpolatedConsumptionByIncome <- apply(
    consumptionAutarkyMatrix,
    1,
    function(x) {
      approx(
        storageGridPoints,
        x,
        income + (1 + returnOnStorage) * storage - consumption,
        rule = 2
      )$y}
  )
  
  return(
    calculateMarginalUtility(consumption, sigma) - (
      beta * (1 + returnOnStorage) * (
        incomeProb %*% calculateMarginalUtility(interpolatedConsumptionByIncome, sigma)
      )
    )
  )
}

interpolateValueByIncome <- function(
    consumption,
    income,
    storage,
    valueAutarkyMatrix,
    storageGridPoints,
    returnOnStorage
) {
  return(
    apply(
      valueAutarkyMatrix,
      1,
      function(x) {
        approx(
          storageGridPoints,
          x,
          income + (1 + returnOnStorage) * storage - consumption,
          rule = 2
          )$y}
      )     
    )
}

updateValueAutarky <- function(
  consumption,
  interpolatedValueByIncome,
  incomeProb,
  beta,
  sigma
) {
  return(
    (
      calculateUtility(consumption, sigma)
      + beta * (
        incomeProb %*% interpolatedValueByIncome
      )
    )
  )
}

computeConsumptionAutarky <- function(
    returnOnStorage,
    storageGridPoints,
    incomeGridPoints,
    beta,
    sigma,
    incomeProb,
    numStates,
    numStorageGridPoints,
    iterationTol = 1e-8,
    maxIteration = 100
) {
  
  consumptionAutarkyMatrix <- outer(rep(1, numStates), (1 / beta - 1) * storageGridPoints) + 1e-8
  consumptionAutarkyMatrixNew <- matrix(NA, nrow = numStates, numStorageGridPoints)

  iter <- 1
  diff <- 1
  while ((diff > iterationTol) & (iter < maxIteration)) {
    
    for (stateIndex in seq(1, numStates)) {
      for (storageIndex in seq(1, numStorageGridPoints)) {
        
        if (calculateEulerEquationDiffAutarky(
            storageGridPoints[storageIndex] * (1 + returnOnStorage) + incomeGridPoints[stateIndex],
            incomeGridPoints[stateIndex],
            storageGridPoints[storageIndex],
            beta,
            sigma,
            returnOnStorage,
            incomeTransitionMatrix[stateIndex,],
            storageGridPoints,
            consumptionAutarkyMatrix
        ) >= 0) {
          consumptionAutarkyMatrixNew[stateIndex, storageIndex] <- (
            storageGridPoints[storageIndex] * (1 + returnOnStorage) + incomeGridPoints[stateIndex]
          )
        } else {
          consumptionAutarkyMatrixNew[stateIndex, storageIndex] <- uniroot(
          function(x) {calculateEulerEquationDiffAutarky(
            x,
            incomeGridPoints[stateIndex],
            storageGridPoints[storageIndex],
            beta,
            sigma,
            returnOnStorage,
            incomeTransitionMatrix[stateIndex, ],
            storageGridPoints,
            consumptionAutarkyMatrix
            )},
            c(
              1e-12, 
              storageGridPoints[storageIndex] * (1 + returnOnStorage) + incomeGridPoints[stateIndex]
              )
          )$root
        }
      }
    }
    
    diff <- max(abs(consumptionAutarkyMatrixNew - consumptionAutarkyMatrix))
    consumptionAutarkyMatrix <- consumptionAutarkyMatrixNew
    iter <- iter + 1
  }
  
  return(consumptionAutarkyMatrix)
}

computeValueAutarky <- function(
    consumptionAutarkyMatrix,
    returnOnStorage,
    storageGridPoints,
    incomeGridPoints,
    beta,
    sigma,
    incomeProb,
    numStates,
    numStorageGridPoints,
    iterationTol = 1e-8,
    maxIteration = 100
) {
  
  valueAutarkyMatrix <- calculateUtility(consumptionAutarkyMatrix, sigma) / (1 - beta)
  valueAutarkyMatrixNew <- matrix(NA, nrow = numStates, ncol = numStorageGridPoints)
  
  iter <- 1
  diff <- 1
  while ((diff > iterationTol) & (iter < maxIteration)) {
    
    for (stateIndex in seq(1, numStates)) {
      for (storageIndex in seq(1, numStorageGridPoints)) {
        
        interpolatedValueByIncome <- interpolateValueByIncome(
          consumptionAutarkyMatrix[stateIndex, storageIndex],
          incomeGridPoints[stateIndex],
          storageGridPoints[storageIndex],
          valueAutarkyMatrix,
          storageGridPoints,
          returnOnStorage
        )
        valueAutarkyMatrixNew[stateIndex, storageIndex] <- updateValueAutarky(
          consumptionAutarkyMatrix[stateIndex, storageIndex],
          interpolatedValueByIncome,
          incomeTransitionMatrix[stateIndex,],
          beta,
          sigma
        ) %>% as.numeric
      }
    }
    
    diff <- max(abs(valueAutarkyMatrixNew - valueAutarkyMatrix))
    valueAutarkyMatrix <- valueAutarkyMatrixNew
    iter <- iter + 1
    
  }
  
  return(valueAutarkyMatrix)
}

solveValueAutarky <- function(
    returnOnStorage,
    storageGridPoints,
    incomeGridPoints,
    beta,
    sigma,
    incomeProb,
    numStates,
    numStorageGridPoints
) {
  
  consumptionAutarkyMatrix <- computeConsumptionAutarky(
      returnOnStorage,
      storageGridPoints,
      incomeGridPoints,
      beta,
      sigma,
      incomeProb,
      numStates,
      numStorageGridPoints
  )
  
  valueAutarkyMatrix <- computeValueAutarky(
      consumptionAutarkyMatrix,
      returnOnStorage,
      storageGridPoints,
      incomeGridPoints,
      beta,
      sigma,
      incomeProb,
      numStates,
      numStorageGridPoints
  )
  
  valueAutarkyZeroPrivateSaving <- valueAutarkyMatrix[, 1]
  
  return(valueAutarkyZeroPrivateSaving)

}


```

```{r}
valueAutarkyHH1 <- solveValueAutarky(
    returnOnStorage,
    storageGridPoints,
    incomeGridPointsHH1,
    beta,
    sigma,
    incomeProb,
    numStates,
    numStorageGridPoints
)

valueAutarkyHH2 <- solveValueAutarky(
    returnOnStorage,
    storageGridPoints,
    incomeGridPointsHH2,
    beta,
    sigma,
    incomeProb,
    numStates,
    numStorageGridPoints
)

```


```{r}
calculateHH1Consumption <- function(
  aggregateResources,
  relativeParetoWeight,
  numHouseholds,
  sigma
) {
    aggregateResources / (1 + (numHouseholds - 1) * (relativeParetoWeight^(1 / sigma)))
}

calculateHH2Consumption <- function(
  aggregateResources,
  relativeParetoWeight,
  numHouseholds,
  sigma
) {
  (
    aggregateResources 
    - aggregateResources / (1 + (numHouseholds - 1) * (relativeParetoWeight^(1 / sigma)))
  )
}

```


```{r}
interpolateValueFunction <- function(
    relativeParetoWeight,
    relativeParetoWeightsGridPoints,
    valueFunctionMatrix
    ) {
  apply(
    valueFunctionMatrix,
    1,
    function(x) {
      approx(
        relativeParetoWeightsGridPoints, 
        x, 
        relativeParetoWeight,
        rule = 2
      )$y
      }
    )
}

# calculateDiffLCRiskSharingAndAutarky <- function(
#     relativeParetoWeight,
#     relativeParetoWeightsGridPoints,
#     delta,
#     sigma,
#     aggregateIncome,
#     householdValueLCRiskSharing,
#     villageValueLCRiskSharing,
#     incomeTransitionProbVec,
#     householdAutarkyValue,
#     villageAutarkyValue,
#     numHouseholds
#     ) {
#   
#   householdConsumption <- calculateHouseholdConsumption(
#     aggregateIncome,
#     relativeParetoWeight,
#     numHouseholds,
#     sigma
#   )
#   
#   householdValueLCRiskSharingAtRelativeParetoWeight <- interpolateValueFunction(
#     relativeParetoWeight,
#     relativeParetoWeightsGridPoints,
#     householdValueLCRiskSharing
#     )
#   villageValueLCRiskSharingAtRelativeParetoWeight <- interpolateValueFunction(
#     relativeParetoWeight,
#     relativeParetoWeightsGridPoints,
#     villageValueLCRiskSharing
#     )
#   
#   householdDiffLCRiskSharingAndAutarky <- (
#     calculateUtility(householdConsumption, sigma) 
#     + delta * incomeTransitionProbVec %*% householdValueLCRiskSharingAtRelativeParetoWeight 
#     - householdAutarkyValue
#   ) %>% as.numeric
#   villageDiffLCRiskSharingAndAutarky <- (
#     calculateUtility((aggregateIncome - householdConsumption) / (numHouseholds - 1), sigma) 
#     + delta * incomeTransitionProbVec %*% villageValueLCRiskSharingAtRelativeParetoWeight 
#     - villageAutarkyValue
#   ) %>% as.numeric
# 
#   return(list(
#     householdDiffLCRiskSharingAndAutarky = householdDiffLCRiskSharingAndAutarky,
#     villageDiffLCRiskSharingAndAutarky = villageDiffLCRiskSharingAndAutarky
#   ))
# }

# calculateValueLCRiskSharing <- function(
#   aggregateIncomeGridPoints,
#   incomeTransitionMatrix,
#   valueAutarkyHH1,
#   valueAutarkyHH2,
#   relativeParetoWeightsGridPoints,
#   numRelativeParetoWeights,
#   delta,
#   sigma,
#   numIncomeStates,
#   numHouseholds,
#   iterationLimit,
#   diffLimit
# ) {
#   
#   consumptionOnRelativeParetoWeightGrid <- matrix(
#     NA, nrow = numStates, ncol = numRelativeParetoWeights
#     )
#   for (stateIndex in seq(1, numStates)) {
#     consumptionOnRelativeParetoWeightGrid[stateIndex, ] <- calculateHouseholdConsumption(
#       aggregateIncomeGridPoints[stateIndex],
#       relativeParetoWeightsGridPoints,
#       numHouseholds,
#       sigma
#     )
#   }
#   consumptionWithoutStorageMatrixHH2 <- aggregateIncomeGridPoints - consumptionOnRelativeParetoWeightGrid
#   valueFullWithoutStorageMatrixHH1 <- (
#     calculateUtility(consumptionOnRelativeParetoWeightGrid, sigma) / (1 - beta)
#   )
#   valueFullWithoutStorageMatrixHH2 <- (
#     calculateUtility(aggregateIncomeGridPoints - consumptionOnRelativeParetoWeightGrid, sigma) / (1 - beta)
#   )
#   
#   # Initial guess is expected utilities under full risk sharing
#   householdValueLCRiskSharing <- valueFullWithoutStorageMatrixHH1
#   villageValueLCRiskSharing <- valueFullWithoutStorageMatrixHH2
#   
#   diff <- 1
#   iteration <- 1
#   while ((diff > diffLimit) && (iteration <= iterationLimit)) {
#     
#     # First, ignore enforceability and just update the value functions
#     # using the values at the previous iteration
#     householdValueLCRiskSharingNew <- (
#       calculateUtility(consumptionOnRelativeParetoWeightGrid, sigma) 
#       + delta * incomeTransitionMatrix %*% householdValueLCRiskSharing
#     )
#     villageValueLCRiskSharingNew <- (
#       calculateUtility(
#         (aggregateIncomeGridPoints - consumptionOnRelativeParetoWeightGrid) / (numHouseholds - 1), 
#         sigma
#         )
#       + delta * incomeTransitionMatrix %*% villageValueLCRiskSharing
#     )
#     
#     # Now check enforceability at each state
#     for (incomeStateIndex in seq(1, numIncomeStates)) {
#       householdAutarkyValue <- valueAutarkyHH1[incomeStateIndex]
#       villageAutarkyValue <- valueAutarkyHH2[incomeStateIndex]
#       
#       if (any(householdValueLCRiskSharingNew[incomeStateIndex, ] <= householdAutarkyValue)) {
#         villageValueLCRiskSharingNew[
#           incomeStateIndex,
#           householdValueLCRiskSharingNew[incomeStateIndex, ] <= householdAutarkyValue
#         ] <- villageValueLCRiskSharingNew[
#           incomeStateIndex,
#           householdValueLCRiskSharingNew[incomeStateIndex, ] <= householdAutarkyValue
#         ] %>% min
#         householdValueLCRiskSharingNew[
#           incomeStateIndex,
#           householdValueLCRiskSharingNew[incomeStateIndex, ] <= householdAutarkyValue
#         ] <- householdAutarkyValue
#       }
#       
#       if (any(villageValueLCRiskSharingNew[incomeStateIndex, ] <= villageAutarkyValue)) {
#         householdValueLCRiskSharingNew[
#           incomeStateIndex,
#           villageValueLCRiskSharingNew[incomeStateIndex, ] <= villageAutarkyValue
#         ] <- householdValueLCRiskSharingNew[
#           incomeStateIndex,
#           villageValueLCRiskSharingNew[incomeStateIndex, ] <= villageAutarkyValue
#         ] %>% min
#         villageValueLCRiskSharingNew[
#           incomeStateIndex,
#           villageValueLCRiskSharingNew[incomeStateIndex, ] <= villageAutarkyValue
#         ] <- villageAutarkyValue
#       }
#     }
#       
#     diff <- max(
#       max(abs(householdValueLCRiskSharingNew - householdValueLCRiskSharing)),
#       max(abs(villageValueLCRiskSharingNew - villageValueLCRiskSharing))
#     )
#     householdValueLCRiskSharing <- householdValueLCRiskSharingNew
#     villageValueLCRiskSharing <- villageValueLCRiskSharingNew
#     iteration <- iteration + 1
#   }
#   
#   relativeParetoWeightBounds <- matrix(NA, nrow = numIncomeStates, ncol = 2)
#   
#   for (incomeStateIndex in seq(1, numIncomeStates)) {
#     aggregateIncome <- aggregateIncomeGridPoints[incomeStateIndex]
#     incomeTransitionProbVec <- incomeTransitionMatrix[incomeStateIndex,]
#     householdAutarkyValue <- valueAutarkyHH1[incomeStateIndex]
#     villageAutarkyValue <- valueAutarkyHH2[incomeStateIndex]
# 
#     if (
#       calculateDiffLCRiskSharingAndAutarky(
#         min(relativeParetoWeightsGridPoints),
#         relativeParetoWeightsGridPoints,
#         delta,
#         sigma,
#         aggregateIncome,
#         householdValueLCRiskSharing,
#         villageValueLCRiskSharing,
#         incomeTransitionProbVec,
#         householdAutarkyValue,
#         villageAutarkyValue,
#         numHouseholds
#         )$villageDiffLCRiskSharingAndAutarky < 0) {
#       if (
#         calculateDiffLCRiskSharingAndAutarky(
#           max(relativeParetoWeightsGridPoints),
#           relativeParetoWeightsGridPoints,
#           delta,
#           sigma,
#           aggregateIncome,
#           householdValueLCRiskSharing,
#           villageValueLCRiskSharing,
#           incomeTransitionProbVec,
#           householdAutarkyValue,
#           villageAutarkyValue,
#           numHouseholds
#           )$villageDiffLCRiskSharingAndAutarky > 0
#       ) {
#         relativeParetoWeightLowerBound <- uniroot(
#           function(x) {calculateDiffLCRiskSharingAndAutarky(
#           x,
#           relativeParetoWeightsGridPoints,
#           delta,
#           sigma,
#           aggregateIncome,
#           householdValueLCRiskSharing,
#           villageValueLCRiskSharing,
#           incomeTransitionProbVec,
#           householdAutarkyValue,
#           villageAutarkyValue,
#           numHouseholds
#           )$villageDiffLCRiskSharingAndAutarky}, 
#         c(min(relativeParetoWeightsGridPoints), max(relativeParetoWeightsGridPoints)), 
#         tol = 1e-10, 
#         maxiter = 300
#         )$root
#         } else {
#           relativeParetoWeightLowerBound <- max(relativeParetoWeightsGridPoints)
#         }
#       } else {
#         relativeParetoWeightLowerBound <- min(relativeParetoWeightsGridPoints)
#       }
#     
#     if (
#       calculateDiffLCRiskSharingAndAutarky(
#         max(relativeParetoWeightsGridPoints),
#         relativeParetoWeightsGridPoints,
#         delta,
#         sigma,
#         aggregateIncome,
#         householdValueLCRiskSharing,
#         villageValueLCRiskSharing,
#         incomeTransitionProbVec,
#         householdAutarkyValue,
#         villageAutarkyValue,
#         numHouseholds
#         )$householdDiffLCRiskSharingAndAutarky < 0) {
#       if (
#         calculateDiffLCRiskSharingAndAutarky(
#           min(relativeParetoWeightsGridPoints),
#           relativeParetoWeightsGridPoints,
#           delta,
#           sigma,
#           aggregateIncome,
#           householdValueLCRiskSharing,
#           villageValueLCRiskSharing,
#           incomeTransitionProbVec,
#           householdAutarkyValue,
#           villageAutarkyValue,
#           numHouseholds
#           )$householdDiffLCRiskSharingAndAutarky > 0
#       ) {
#         relativeParetoWeightUpperBound <- uniroot(
#           function(x) {calculateDiffLCRiskSharingAndAutarky(
#           x,
#           relativeParetoWeightsGridPoints,
#           delta,
#           sigma,
#           aggregateIncome,
#           householdValueLCRiskSharing,
#           villageValueLCRiskSharing,
#           incomeTransitionProbVec,
#           householdAutarkyValue,
#           villageAutarkyValue,
#           numHouseholds
#           )$householdDiffLCRiskSharingAndAutarky}, 
#         c(min(relativeParetoWeightsGridPoints), max(relativeParetoWeightsGridPoints)), 
#         tol = 1e-10, 
#         maxiter = 300
#         )$root
#         } else {
#           relativeParetoWeightUpperBound <- min(relativeParetoWeightsGridPoints)
#         }
#       } else {
#         relativeParetoWeightUpperBound <- max(relativeParetoWeightsGridPoints)
#       }
#       relativeParetoWeightBounds[incomeStateIndex, 1] <- relativeParetoWeightLowerBound
#       relativeParetoWeightBounds[incomeStateIndex, 2] <- relativeParetoWeightUpperBound
#   }
#   
#   if (iteration == iterationLimit) {
#     print("Reached the maximum limit of iterations!")
#   }
#   
#   return(list(
#     householdValueLCRiskSharing = householdValueLCRiskSharing,
#     villageValueLCRiskSharing = villageValueLCRiskSharing,
#     relativeParetoWeightBounds = relativeParetoWeightBounds))
# }




```

```{r}
# tmp <- calculateValueLCRiskSharing(
#   aggregateIncomeGridPoints,
#   incomeTransitionMatrix,
#   valueAutarkyHH1,
#   valueAutarkyHH2,
#   relativeParetoWeightsGridPoints,
#   numRelativeParetoWeights,
#   beta,
#   sigma,
#   numStates,
#   numHouseholds,
#   iterationLimit = 100,
#   diffLimit = 1e-8
# )

# currentHouseholdConsumption <- do.call(
#   rbind,
#   map(
#     seq(1, numStates),
#     ~ calculateHouseholdConsumption(
#       aggregateIncomeGridPoints[.],
#       relativeParetoWeightsGridPoints,
#       numHouseholds,
#       sigma
#     )
#   )
# )
# 
# nextPeriodHouseholdConsumption <- do.call(
#   rbind,
#   map(
#     seq(1, numStates),
#     function(x) calculateHouseholdConsumption(
#       aggregateIncomeGridPoints[x],
#       relativeParetoWeightsGridPoints %>% 
#         pmax(tmp$relativeParetoWeightBounds[x,1]) %>% 
#         pmin(tmp$relativeParetoWeightBounds[x,2]),
#       numHouseholds,
#       sigma
#     )
#   )
# )

# socialPlannerEulerInequalityWithoutStorage <- (
#   calculateMarginalUtility(
#     currentHouseholdConsumption, sigma
#   ) >= 
#     beta * (1 + returnOnStorage) * (
#       incomeTransitionMatrix %*% (
#         calculateMarginalUtility(nextPeriodHouseholdConsumption, sigma) / 
#           (
#             do.call(
#               rbind,
#               map(
#                 seq(1, numStates),
#                 function(x) {
#                   ((
#                     relativeParetoWeightsGridPoints %>%
#                       pmax(tmp$relativeParetoWeightBounds[x,1]) %>%
#                       pmin(tmp$relativeParetoWeightBounds[x,2])
#                     ) / relativeParetoWeightsGridPoints) %>% pmin(1)
#                   }
#                 )
#               )
#             )
#         )
#       )
#   )


```


## Full model

Prepare $V_1^0(y, B, x)$, $V_2^0(y, B, x)$, $\underline{x}^0(y, B)$, $\overline{x}^0(y, B)$, and $B'^0(y, B, x)$.

1. First, I update $\overline{x}(y, B)$. For this, first solve for $x$ such that the household 1's participation constraint binds with 0 next-period saving:
$$
  u(c_1(y, B, \overline{x}(y, B))) + \beta \sum_{y'} Pr(y') V_1^{h - 1}(y', 0, \overline{x}(y, B)) = U_1^{aut}(y),
$$
where $c_1(y, B, \overline{x}(y, B))$ satisfies
$$
  \overline{x}(y, B) = \frac{u'(y + (1 + r) B - c_1(y, B, \overline{x}(y, B)))}{u'(c_1(y, B, \overline{x}(y, B)))}.
$$
2. To check if the planner's Euler equation is satisfied, calculate
$$
  u'(c_1(y, B, \overline{x}(y, B))) - \beta (1 + r) \sum_{y'} Pr(y') u'(c_1(y', 0, \overline{x}(y, B))),
$$
where, since both the previous period and the current period relative Pareto weights are $\overline{x}(y, B)$, $1 - \nu_1 = 1$, and hence I can ignore this term.
If this is non-negative, update $B'^h(y, B, \overline{x}(y, B)) = 0$ and $\overline{x}^h(y, B) = \overline{x}(y, B)$.
If this negative, then since the planner's Euler equation is violated with $B' = 0$, I solve the following non-linear system of two equations:
$$
\begin{aligned}
  &u'(c_1(y, B, \overline{x}(y, B))) - \beta (1 + r) \sum_{y'} Pr(y') u'(c_1(y', B', \overline{x}(y, B))) = 0 \\
  &u(c_1(y, B, \overline{x}(y, B))) + \beta \sum_{y'} Pr(y') V_1^{h - 1}(y', B', \overline{x}(y, B)) = U_1^{aut}(y),
\end{aligned}
$$
and update $B'^h(y, B, \overline{x}(y, B))$ and $\overline{x}^h(y, B)$ with the solutions.
3. Next, I update $\underline{x}(y, B)$ in a similar way. First solve for $x$ such that the household 2's participation constraint binds with 0 next-period saving:
$$
  u(c_2(y, B, \underline{x}(y, B))) + \beta \sum_{y'} Pr(y') V_2^{h - 1}(y', 0, \underline{x}(y, B)) = U_2^{aut}(y),
$$
where $c_2(y, B, \underline{x}(y, B))$ satisfies
$$
  \underline{x}(y, B) = \frac{u'(y + (1 + r) B - c_2(y, B, \underline{x}(y, B)))}{u'(c_2(y, B, \underline{x}(y, B)))}.
$$
4. To check if the planner's Euler equation is satisfied, calculate
$$
  u'(c_1(y, B, \underline{x}(y, B))) - \beta (1 + r) \sum_{y'} Pr(y') u'(c_1(y', 0, \underline{x}(y, B))),
$$
where, since both the previous period and the current period relative Pareto weights are $\underline{x}(y, B)$, $1 - \nu_1 = 1$, and hence I can ignore this term.
If this is non-negative, update $B'^h(y, B, \underline{x}(y, B)) = 0$ and $\underline{x}^h(y, B) = \underline{x}(y, B)$.
If this negative, then since the planner's Euler equation is violated with $B' = 0$, I solve the following non-linear system of two equations:
$$
\begin{aligned}
  &u'(c_1(y, B, \underline{x}(y, B))) - \beta (1 + r) \sum_{y'} Pr(y') u'(c_1(y', B', \underline{x}(y, B))) = 0 \\
  &u(c_2(y, B, \underline{x}(y, B))) + \beta \sum_{y'} Pr(y') V_2^{h - 1}(y', B', \underline{x}(y, B)) = U_2^{aut}(y),
\end{aligned}
$$
and update $B'^h(y, B, \underline{x}(y, B))$ and $\underline{x}^h(y, B)$ with the solutions.
5. For each $(y, B)$, for $x \in [\underline{x}(y, B), \overline{x}(y, B)]$, where no participation constraint binds, update $B'$ by solving the planner's Euler equation holds with equality (note that $\nu$ disappears since participation constraints do not bind):
$$
  u'(c_1(y, B, x)) = \beta (1 + r) \sum_{y'} Pr(y') u'(c_1(y', B', x)),
$$
where current consumption is determined by
$$
  x = \frac{u'(y + (1 + r) B - B' - c_1(y, B, x))}{u'(c_1(y, B, x))}.
$$
The next-period consumption is determined by
$$
  \tilde{x}(y', B', x) = \frac{u'(y' + (1 + r) B' - B'^{h - 1}(y', B', \tilde{x}(y', B', x)) - c_1(y', B', x))}{u'(c_1(y', B', x))},
$$
where $\tilde{x}(y', B', x)$ is derived by updating $x$ with the relative Pareto weight interval, $[\underline{x}^{h - 1}(y', B'), \overline{x}^{h - 1}(y', B')]$.
Let the derived $B'$ be $\tilde{B}'(y, B, x)$ and temporalilly update $B'^h(y, B, x) = \tilde{B}'(y, B, x)$.
And update the values with
$$
\begin{aligned}
  &V_1^h(y, B, x) = u(c_1(y, B, x)) + \beta \sum_{y'} V_1^{h - 1}(y', B'^{h}(y, B, x), x) \\
  &V_2^h(y, B, x) = u(c_2(y, B, x)) + \beta \sum_{y'} V_2^{h - 1}(y', B'^{h}(y, B, x), x)
\end{aligned}
$$
For $x < \underline{x}(y, B)$, set
$$
\begin{aligned}
  &V_1^h(y, B, x) = u(c_1(y, B, \underline{x}(y, B))) + \beta \sum_{y'} V_1^{h - 1}(y', B'^{h}(y, B, \underline{x}(y, B)), \underline{x}(y, B)) \\
  &V_2^h(y, B, x) = U_2^{aut}(y)
\end{aligned}
$$
and for $x > \overline{x}(y, B)$, set
$$
\begin{aligned}
  &V_1^h(y, B, x) = U_1^{aut}(y) \\
  &V_2^h(y, B, x) = u(c_2(y, B, \overline{x}(y, B))) + \beta \sum_{y'} V_2^{h - 1}(y', B'^{h}(y, B, \overline{x}(y, B)), \overline{x}(y, B)).
\end{aligned}
$$

Repeat this until value functions converge.
I use linear interpoations to interpolate values between grid points in policy functions and value functions.

```{r, eval = FALSE}

consumptionOnRelativeParetoWeightAndStorageGridHH1 <- array(
  NA, dim = c(numStates, numRelativeParetoWeights, numStorageGridPoints)
  )
for (stateIndex in seq(1, numStates)) {
  for (weightIndex in seq(1, numRelativeParetoWeights)) {
    consumptionOnRelativeParetoWeightAndStorageGridHH1[stateIndex, weightIndex, ] <- (
        calculateHH1Consumption(
        aggregateIncomeGridPoints[stateIndex] + (1 + returnOnStorage) * storageGridPoints,
        relativeParetoWeightsGridPoints[weightIndex],
        numHouseholds,
        sigma
      )
    )
  }
}
consumptionOnRelativeParetoWeightAndStorageGridHH2 <- array(
  NA, dim = c(numStates, numRelativeParetoWeights, numStorageGridPoints)
  )
for (stateIndex in seq(1, numStates)) {
  for (weightIndex in seq(1, numRelativeParetoWeights)) {
    consumptionOnRelativeParetoWeightAndStorageGridHH2[stateIndex, weightIndex, ] <- (
        aggregateIncomeGridPoints[stateIndex] + (1 + returnOnStorage) * storageGridPoints - 
          consumptionOnRelativeParetoWeightAndStorageGridHH1[stateIndex, weightIndex, ]
      )
  }
}

valueArrayHH1 <- (
  calculateUtility(consumptionOnRelativeParetoWeightAndStorageGridHH1, sigma) / (1 - beta)
)
valueArrayHH2 <- (
  calculateUtility(consumptionOnRelativeParetoWeightAndStorageGridHH2, sigma) / (1 - beta)
)
valueArrayHH1New <- valueArrayHH1
valueArrayHH2New <- valueArrayHH2

```

```{r, eval = FALSE}

relativeParetoWeightsBoundsArray <- array(
  NA, dim = c(2, numStates, numStorageGridPoints)
)
relativeParetoWeightsBoundsArray[1, ,] <- min(relativeParetoWeightsGridPoints)
relativeParetoWeightsBoundsArray[2, ,] <- max(relativeParetoWeightsGridPoints)
relativeParetoWeightsBoundsArrayNew <- array(
  NA, dim = c(2, numStates, numStorageGridPoints)
)

nextStorageArray <- array(
  0, dim = c(numStates, numRelativeParetoWeights, numStorageGridPoints)
  )
nextStorageArrayNew <- array(
  0, dim = c(numStates, numRelativeParetoWeights, numStorageGridPoints)
  )

stateIndex <- 2
nextStorage <- 0
storageIndex <- 100

```

```{r}
calculateEulerEquationDiff <- function(
    aggregateIncome,
    currentStorage,
    currentRelativeParetoWeight,
    returnOnStorage,
    nextPeriodStorage,
    aggregateIncomeGridPoints,
    relativeParetoWeightsGridPoints,
    nextStorageArray,
    relativeParetoWeightsBoundsArray,
    incomeTransitionProbVec,
    numHouseholds,
    numStates,
    sigma,
    beta
) {
  
  nextRelativeParetoWeight <- map_dbl(
    seq(1, numStates),
    function(x) {
      currentRelativeParetoWeight %>% 
      pmax(
        approx(
          storageGridPoints,
          relativeParetoWeightsBoundsArray[1, x, ],
          nextStorage
        )$y
      ) %>% 
      pmin(
        approx(
          storageGridPoints,
          relativeParetoWeightsBoundsArray[2, x, ],
          nextStorage
        )$y
      )
      
    }
  )
  
  return(
    calculateMarginalUtility(
      calculateHH1Consumption(
          aggregateIncome
          + (1 + returnOnStorage) * currentStorage - nextPeriodStorage,
          currentRelativeParetoWeight,
          numHouseholds,
          sigma
        ),
      sigma
    ) - (
      beta * (1 + returnOnStorage) * incomeTransitionProbVec %*% (
        calculateMarginalUtility(
          calculateHH1Consumption(
            aggregateIncomeGridPoints 
            + (1 + returnOnStorage) * nextPeriodStorage 
            - map_dbl(
              seq(1, numStates),
              function(x) interp2(
                x = storageGridPoints,
                y = relativeParetoWeightsGridPoints,
                Z = nextStorageArray[x, , ],
                xp = nextStorage,
                yp = nextRelativeParetoWeight[x],
                method = "linear"
                )
              ),
            nextRelativeParetoWeight,
            numHouseholds,
            sigma
          ),
          sigma
        )
      ) %>% as.numeric 
    )
  )
}

calculateValue <- function(
    aggregateIncome,
    currentStorage,
    currentRelativeParetoWeight,
    returnOnStorage,
    nextPeriodStorage,
    relativeParetoWeightsGridPoints,
    valueArray,
    incomeTransitionProbVec,
    numHouseholds,
    numStates,
    sigma,
    beta,
    calculateHouseholdConsumption
) {
 
  return(
    calculateUtility(
      calculateHouseholdConsumption(
        aggregateIncome
        + (1 + returnOnStorage) * currentStorage
        - nextPeriodStorage,
        currentRelativeParetoWeight,
        numHouseholds,
        sigma
      )
      , sigma
    ) + (
      beta 
      * incomeTransitionProbVec 
      %*% map_dbl(
        seq(1, numStates),
        function(x) {interp2(
            x = storageGridPoints,
            y = relativeParetoWeightsGridPoints,
            Z = valueArray[x, , ],
            xp = nextStorage,
            yp = currentRelativeParetoWeight,
            method = "linear"
        )}
        ) %>% as.numeric)
  )
}

calculatePCDiff <- function(
    aggregateIncome,
    currentStorage,
    currentRelativeParetoWeight,
    returnOnStorage,
    nextPeriodStorage,
    relativeParetoWeightsGridPoints,
    valueArray,
    valueAutarky,
    incomeTransitionProbVec,
    numHouseholds,
    numStates,
    sigma,
    beta,
    calculateHouseholdConsumption
) {
    return(
      calculateValue(
        aggregateIncome,
        currentStorage,
        currentRelativeParetoWeight,
        returnOnStorage,
        nextPeriodStorage,
        relativeParetoWeightsGridPoints,
        valueArray,
        incomeTransitionProbVec,
        numHouseholds,
        numStates,
        sigma,
        beta,
        calculateHouseholdConsumption
        ) - valueAutarky[stateIndex]
    )
}

```


```{r, eval = FALSE}

for (stateIndex in seq(1, numStates)) {
  print(stateIndex)
  tic()
  for (storageIndex in seq(1, numStorageGridPoints)) {
    
    # (i)
    if (
      calculatePCDiff(
            aggregateIncome,
            currentStorage = storageGridPoints[storageIndex],
            currentRelativeParetoWeight = min(relativeParetoWeightsGridPoints),
            returnOnStorage,
            nextPeriodStorage = 0,
            relativeParetoWeightsGridPoints,
            valueArray = valueArrayHH1,
            valueAutarky = valueAutarkyHH1,
            incomeTransitionProbVec,
            numHouseholds,
            numStates,
            sigma,
            beta,
            calculateHH1Consumption
          ) > 0
    ) {
      relativeParetoWeightsUpperTmp <- max(relativeParetoWeightsGridPoints)
    } else {
      relativeParetoWeightsUpperTmp <- uniroot(
        function(x) {
          calculatePCDiff(
            aggregateIncome,
            currentStorage = storageGridPoints[storageIndex],
            currentRelativeParetoWeight = x,
            returnOnStorage,
            nextPeriodStorage = 0,
            relativeParetoWeightsGridPoints,
            valueArray = valueArrayHH1,
            valueAutarky = valueAutarkyHH1,
            incomeTransitionProbVec,
            numHouseholds,
            numStates,
            sigma,
            beta,
            calculateHH1Consumption
          )
        },
        c(min(relativeParetoWeightsGridPoints), max(relativeParetoWeightsGridPoints))
      )$root
    }
    
    # (ii)
    if (
      calculateEulerEquationDiff(
        aggregateIncomeGridPoints[stateIndex],
        storageGridPoints[storageIndex],
        currentRelativeParetoWeight = relativeParetoWeightsUpperTmp,
        returnOnStorage,
        nextPeriodStorage = 0,
        aggregateIncomeGridPoints,
        relativeParetoWeightsGridPoints,
        nextStorageArray,
        relativeParetoWeightsBoundsArray,
        incomeTransitionProbVec,
        numHouseholds,
        numStates,
        sigma,
        beta
        ) >= 0
    ) {
      nextStorageArrayNew[
        stateIndex, 
        which.min(abs(
          relativeParetoWeightsUpperTmp - relativeParetoWeightsGridPoints
          )), 
        storageIndex
        ] <- 0
      relativeParetoWeightsBoundsArrayNew[2, stateIndex, storageIndex] <- relativeParetoWeightsUpperTmp
    } else {
      resSolve <- nleqslv(
        c(0, 1),
        function(x) {
          nextPeriodStorage <- x[1]
          relativeParetoWeightUpperBound <- x[2]
          y <- numeric(2)
          
          y[1] <- calculateEulerEquationDiff(
            aggregateIncomeGridPoints[stateIndex],
            storageGridPoints[storageIndex],
            currentRelativeParetoWeight = relativeParetoWeightUpperBound,
            returnOnStorage,
            nextPeriodStorage = nextPeriodStorage,
            aggregateIncomeGridPoints,
            relativeParetoWeightsGridPoints,
            nextStorageArray,
            relativeParetoWeightsBoundsArray,
            incomeTransitionProbVec,
            numHouseholds,
            numStates,
            sigma,
            beta
            )
          
          y[2] <- calculatePCDiff(
            aggregateIncomeGridPoints[stateIndex],
            storageGridPoints[storageIndex],
            currentRelativeParetoWeight = relativeParetoWeightUpperBound,
            returnOnStorage,
            nextPeriodStorage = nextPeriodStorage,
            relativeParetoWeightsGridPoints,
            valueArray = valueArrayHH1,
            valueAutarky = valueAutarkyHH1,
            incomeTransitionProbVec,
            numHouseholds,
            numStates,
            sigma,
            beta,
            calculateHH1Consumption
            )
          
          return(y)
        }
      )$x
      nextStorageArrayNew[
        stateIndex, 
        which.min(abs(
          resSolve[2] - relativeParetoWeightsGridPoints
          )), 
        storageIndex
        ] <- resSolve[1]
      relativeParetoWeightsBoundsArrayNew[2, stateIndex, storageIndex] <- resSolve[2]
    }
    
    # (iii)
    if (
      calculatePCDiff(
        aggregateIncomeGridPoints[stateIndex],
        currentStorage = storageGridPoints[storageIndex],
        currentRelativeParetoWeight = min(relativeParetoWeightsGridPoints),
        returnOnStorage,
        nextPeriodStorage = 0,
        relativeParetoWeightsGridPoints,
        valueArray = valueArrayHH2,
        valueAutarky = valueAutarkyHH2,
        incomeTransitionProbVec,
        numHouseholds,
        numStates,
        sigma,
        beta,
        calculateHH2Consumption
      ) > 0
    ) {
      relativeParetoWeightsLowerTmp <- min(relativeParetoWeightsGridPoints)
    } else {
      relativeParetoWeightsLowerTmp <- uniroot(
        function(x) {
          calculatePCDiff(
            aggregateIncomeGridPoints[stateIndex],
            currentStorage = storageGridPoints[storageIndex],
            currentRelativeParetoWeight = x,
            returnOnStorage,
            nextPeriodStorage = 0,
            relativeParetoWeightsGridPoints,
            valueArray = valueArrayHH2,
            valueAutarky = valueAutarkyHH2,
            incomeTransitionProbVec,
            numHouseholds,
            numStates,
            sigma,
            beta,
            calculateHH2Consumption
          )
        },
        c(min(relativeParetoWeightsGridPoints), max(relativeParetoWeightsGridPoints))
      )$root
    }
    
    # (iv)
    calculateEulerEquationDiff(
        aggregateIncomeGridPoints[stateIndex],
        storageGridPoints[storageIndex],
        currentRelativeParetoWeight = relativeParetoWeightsLowerTmp,
        returnOnStorage,
        nextPeriodStorage = 0,
        aggregateIncomeGridPoints,
        relativeParetoWeightsGridPoints,
        nextStorageArray,
        relativeParetoWeightsBoundsArray,
        incomeTransitionProbVec,
        numHouseholds,
        numStates,
        sigma,
        beta
    ) 
    
    if (
      calculateEulerEquationDiff(
        aggregateIncomeGridPoints[stateIndex],
        storageGridPoints[storageIndex],
        currentRelativeParetoWeight = relativeParetoWeightsLowerTmp,
        returnOnStorage,
        nextPeriodStorage = 0,
        aggregateIncomeGridPoints,
        relativeParetoWeightsGridPoints,
        nextStorageArray,
        relativeParetoWeightsBoundsArray,
        incomeTransitionProbVec,
        numHouseholds,
        numStates,
        sigma,
        beta
        ) >= 0
    ) {
      nextStorageArrayNew[
        stateIndex, 
        which.min(abs(
          relativeParetoWeightsLowerTmp - relativeParetoWeightsGridPoints
          )), 
        storageIndex
        ] <- 0
      relativeParetoWeightsBoundsArrayNew[1, stateIndex, storageIndex] <- relativeParetoWeightsLowerTmp
    } else {
      resSolve <- nleqslv(
        c(0, 1),
        function(x) {
          nextPeriodStorage <- x[1]
          relativeParetoWeightLowerBound <- x[2]
          y <- numeric(2)
          
          y[1] <- calculateEulerEquationDiff(
            aggregateIncomeGridPoints[stateIndex],
            storageGridPoints[storageIndex],
            currentRelativeParetoWeight = relativeParetoWeightLowerBound,
            returnOnStorage,
            nextPeriodStorage = nextPeriodStorage,
            aggregateIncomeGridPoints,
            relativeParetoWeightsGridPoints,
            nextStorageArray,
            relativeParetoWeightsBoundsArray,
            incomeTransitionProbVec,
            numHouseholds,
            numStates,
            sigma,
            beta
            )
          
          y[2] <- calculatePCDiff(
            aggregateIncomeGridPoints[stateIndex],
            storageGridPoints[storageIndex],
            currentRelativeParetoWeight = relativeParetoWeightLowerBound,
            returnOnStorage,
            nextPeriodStorage = nextPeriodStorage,
            relativeParetoWeightsGridPoints,
            valueArray = valueArrayHH2,
            valueAutarky = valueAutarkyHH2,
            incomeTransitionProbVec,
            numHouseholds,
            numStates,
            sigma,
            beta,
            calculateHH2Consumption
            )
          
          return(y)
        }
      )$x
      nextStorageArrayNew[
        stateIndex, 
        which.min(abs(
          resSolve[2] - relativeParetoWeightsGridPoints
          )), 
        storageIndex
        ] <- resSolve[1]
      relativeParetoWeightsBoundsArrayNew[1, stateIndex, storageIndex] <- resSolve[2]
    }
    
    # (v)
    relativeParetoWeightsLower <- relativeParetoWeightsBoundsArrayNew[1, stateIndex, storageIndex]
    relativeParetoWeightsUpper <- relativeParetoWeightsBoundsArrayNew[2, stateIndex, storageIndex]
    
    relativeParetoWeightsLowerIndex <- which(relativeParetoWeightsGridPoints > relativeParetoWeightsLower)[1]
    relativeParetoWeightsUpperIndex <- rev(which(relativeParetoWeightsGridPoints < relativeParetoWeightsUpper))[1]
    
    for (weightIndex in seq(relativeParetoWeightsLowerIndex, relativeParetoWeightsUpperIndex)) {
      
      if (
       calculateEulerEquationDiff(
          aggregateIncomeGridPoints[stateIndex],
          storageGridPoints[storageIndex],
          relativeParetoWeightsGridPoints[weightIndex],
          returnOnStorage,
          0,
          aggregateIncomeGridPoints,
          relativeParetoWeightsGridPoints,
          nextStorageArray,
          relativeParetoWeightsBoundsArray,
          incomeTransitionMatrix[stateIndex,],
          numHouseholds,
          numStates,
          sigma,
          beta
      ) > 0) {
        nextStorageArrayNew[stateIndex, weightIndex, storageIndex] <- 0
      } else {
        nextStorageArrayNew[stateIndex, weightIndex, storageIndex] <- uniroot(
          function(x) {calculateEulerEquationDiff(
            aggregateIncomeGridPoints[stateIndex],
            storageGridPoints[storageIndex],
            relativeParetoWeightsGridPoints[weightIndex],
            returnOnStorage,
            x,
            aggregateIncomeGridPoints,
            relativeParetoWeightsGridPoints,
            nextStorageArray,
            relativeParetoWeightsBoundsArray,
            incomeTransitionMatrix[stateIndex,],
            numHouseholds,
            numStates,
            sigma,
            beta
            )
            },
          c(0, aggregateIncomeGridPoints[stateIndex] + storageGridPoints[storageIndex] - 1e-12)
          )$root
      }
      valueArrayHH1New[stateIndex, weightIndex, storageIndex] <- calculateValue(
        aggregateIncomeGridPoints[stateIndex],
        storageGridPoints[storageIndex],
        currentRelativeParetoWeight = relativeParetoWeightsGridPoints[weightIndex],
        returnOnStorage,
        nextPeriodStorage = nextStorageArrayNew[stateIndex, weightIndex, storageIndex],
        relativeParetoWeightsGridPoints,
        valueArrayHH1,
        incomeTransitionProbVec,
        numHouseholds,
        numStates,
        sigma,
        beta,
        calculateHH1Consumption
        )
      
      valueArrayHH2New[stateIndex, weightIndex, storageIndex] <- calculateValue(
        aggregateIncomeGridPoints[stateIndex],
        storageGridPoints[storageIndex],
        currentRelativeParetoWeight = relativeParetoWeightsGridPoints[weightIndex],
        returnOnStorage,
        nextPeriodStorage = nextStorageArrayNew[stateIndex, weightIndex, storageIndex],
        relativeParetoWeightsGridPoints,
        valueArrayHH2,
        incomeTransitionProbVec,
        numHouseholds,
        numStates,
        sigma,
        beta,
        calculateHH2Consumption
        )
    }
    
    valueArrayHH1New[
      stateIndex,
      relativeParetoWeightsGridPoints <= relativeParetoWeightsLower,
      storageIndex
      ] <- valueArrayHH1New[
        stateIndex,
        relativeParetoWeightsLowerIndex,
        storageIndex
      ] 
    valueArrayHH1New[
      stateIndex,
      relativeParetoWeightsGridPoints >= relativeParetoWeightsUpper,
      storageIndex
      ] <- valueAutarkyHH1[stateIndex]
    
    valueArrayHH2New[
      stateIndex,
      relativeParetoWeightsGridPoints >= relativeParetoWeightsUpper,
      storageIndex
      ] <- valueArrayHH2New[
        stateIndex,
        relativeParetoWeightsUpperIndex,
        storageIndex
      ] 
    valueArrayHH2New[
      stateIndex,
      relativeParetoWeightsGridPoints <= relativeParetoWeightsLower,
      storageIndex
      ] <- valueAutarkyHH2[stateIndex]
  }
  toc()
}

diff <- max(c(
  max(abs(valueArrayHH1New - valueArrayHH1)),
  max(abs(valueArrayHH2New - valueArrayHH2))
))

relativeParetoWeightsBoundsArray <- relativeParetoWeightsBoundsArrayNew
nextStorageArray <- nextStorageArrayNew
valueArrayHH1 <- valueArrayHH1New
valueArrayHH2 <- valueArrayHH2New

valueArrayHH1New[1, , 100] %>% plot
valueArrayHH2New[1, , 100] %>% plot
nextStorageArrayNew[1, 1, ] %>% plot
which.min(abs(relativeParetoWeightsBoundsArray[1,1,1] - relativeParetoWeightsGridPoints))
which.min(abs(relativeParetoWeightsBoundsArray[2,1,1] - relativeParetoWeightsGridPoints))

```



