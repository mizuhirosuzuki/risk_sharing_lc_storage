[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Risk-sharing with limited commitment and storage",
    "section": "",
    "text": "Preface\nThis website explains a risk-sharing model with storage under limited commitment, based on Ábrahám and Laczó (2018). After reviewing the model, I show how to numerically solve it, and then I demonstrate a simulation result to deep-dive into the model implications. Finally, I compare the result with the case without storage (as in Ligon, Thomas, and Worrall (2002)) and show that the possibility of storage can worsen households’ welfare.\nFor writing R codes in this website, I refer to the Matlab scripts in the replication package of Ábrahám and Laczó (2018) provided in the journal website. Any errors are my own, and if you find any mistakes or wrong statements, feel free to report it to me, through the GitHub’s issue page or via email.\nContact: Mizuhiro Suzuki (mizuhiro.suzuki@gmail.com)\nGitHub repo: https://github.com/mizuhirosuzuki/risk_sharing_lc_storage"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "lc_storage_model.html#value-of-autarky-with-storage",
    "href": "lc_storage_model.html#value-of-autarky-with-storage",
    "title": "1  Risk sharing with limited commitment and storage: Model",
    "section": "1.1 Value of autarky with storage",
    "text": "1.1 Value of autarky with storage\nThe expected lifetime utility of an agent i under autarky with storage, at a state s with private savings b, is \n  V_i^{aut}(s, b) = \\max_{b' \\ge 0} \\left\\{ u(y_i^s + (1 + r) b - b') + \\beta \\sum_{j} \\pi^j V_i^{aut} (y^j, b') \\right\\}.\n The intertemporal optimality condition, that is, the (individual) Euler equation, is \n  u'(c(s, b)) \\ge (1 + r) \\beta \\sum_j \\pi^j c(j, b'(s, b)),\n where the equality holds if \\beta'(s, b) \\ge 0. Note that b'(s, b) = y_i^s + (1 + r) b - c(s, b). I use the policy function iteration method to calculate c(s, b).\nWhat we are interested in is U_i^{aut} \\equiv V_i^{aut}(s, 0), that is, the autarky value when there is no private saving, since this is the state households consider in participation constraints."
  },
  {
    "objectID": "lc_storage_solution.html#steps-for-solving-the-model",
    "href": "lc_storage_solution.html#steps-for-solving-the-model",
    "title": "2  Risk sharing with limited commitment and storage: Numerical solution",
    "section": "2.1 Steps for solving the model",
    "text": "2.1 Steps for solving the model\nBased on the modeling solution described in the previous page, I explain how to solve the model numerically. First, prepare V_1^0(y, B, x), V_2^0(y, B, x), \\underline{x}^0(y, B), \\overline{x}^0(y, B), and B'^0(y, B, x), and below I describe the steps in h’th iteration. Note that the updating rule of relative Pareto weight, x'^h(y, B, x) is determined by (\\underline{x}^h(y, B), \\overline{x}^h(y, B)).\n\nFirst, I update \\overline{x}(y, B). For this, solve for \\overline{x}(y, B) in the equation below such that the household 1’s participation constraint binds with 0 next-period saving: \n  u(c_1(y, B, \\overline{x}(y, B))) + \\beta \\sum_{y'} Pr(y') V_1^{h - 1}(y', 0, \\overline{x}(y, B)) = U_1^{aut}(y),\n where \n  c_1(y, B, \\overline{x}(y, B)) = \\frac{y + (1 + r)B}{1 + \\overline{x}(y, B)}.\n Then check if the planner’s Euler equation is satisfied at this \\overline{x}(y, B), by seeing if the following expression is non-negative or not: \n  u'(c_1(y, B, \\overline{x}(y, B))) - \\beta (1 + r) \\sum_{y'} Pr(y') \\frac{u'(c_1(y', 0, \\overline{x}(y, B)))}{1 - \\nu_1(y', 0, \\overline{x}(y, B))},\n where, \n\\begin{aligned}\n  c_1(y', 0, \\overline{x}(y, B)) &= \\frac{y' - B'^{(h - 1)}(y', 0, \\overline{x}(y, B))}{1 + x'^{(h - 1)}(y', 0, \\overline{x}(y, B))} \\\\\n  \\nu_1(y', 0, \\overline{x}(y, B)) &= \\min \\left\\{ 1 - \\frac{x'^{(h - 1)}(y', 0, \\overline{x}(y, B))}{\\overline{x}(y, B)}, 1 \\right\\}.\n\\end{aligned}\n If this is non-negative, update B'^h(y, B, \\overline{x}(y, B)) = 0 and \\overline{x}^h(y, B) = \\overline{x}(y, B). If this is negative, then since the planner’s Euler equation is violated with B' = 0, I solve the following non-linear system of two equations for \\overline{x}(y, B) and B': \n\\begin{aligned}\n  &u'(c_1(y, B, \\overline{x}(y, B))) - \\beta (1 + r) \\sum_{y'} Pr(y') \\frac{u'(c_1(y', B', \\overline{x}(y, B)))}{1 - \\nu_1(y', B', \\overline{x}(y, B))} = 0 \\\\\n  &u(c_1(y, B, \\overline{x}(y, B))) + \\beta \\sum_{y'} Pr(y') V_1^{h - 1}(y', B', \\overline{x}(y, B)) = U_1^{aut}(y),\n\\end{aligned}\n and update B'^h(y, B, \\overline{x}(y, B)) and \\overline{x}^h(y, B) with the solutions. The value functions are updated such that \n\\begin{aligned}\n  V_1^{h}(y, B, \\overline{x}(y, B)) &= U_1^{aut}(y) \\\\\n  V_2^{h}(y, B, \\overline{x}(y, B)) &= u(c_2(y, B, \\overline{x}(y, B))) + \\beta \\sum_{y'} Pr(y') V_2^{h - 1}(y', B'^h(y, B, \\overline{x}(y, B)), \\overline{x}(y, B)).\n\\end{aligned}\n\nNext, I update \\underline{x}(y, B) in a similar way. First solve for \\underline{x}(y, B) such that the household 2’s participation constraint binds with 0 next-period saving: \n  u(c_2(y, B, \\underline{x}(y, B))) + \\beta \\sum_{y'} Pr(y') V_2^{h - 1}(y', 0, \\underline{x}(y, B)) = U_2^{aut}(y),\n where \n  c_2(y, B, \\underline{x}(y, B)) = \\frac{y + (1 + r)B}{1 + 1 / \\underline{x}(y, B)}.\n And I check if the planner’s Euler equation is satisfied at \\overline{x}(y, B) with B' = 0, by checking if \n  u'(c_1(y, B, \\underline{x}(y, B))) - \\beta (1 + r) \\sum_{y'} Pr(y') \\frac{u'(c_1(y', 0, \\underline{x}(y, B)))}{1 - \\nu_1(y', 0, \\underline{x}(y, B))} \\ge 0\n or not. If this is the case, update B'^h(y, B, \\underline{x}(y, B)) = 0 and \\underline{x}^h(y, B) = \\underline{x}(y, B). Otherwise, since the planner’s Euler equation is violated with B' = 0, I solve the following non-linear system of two equations for B' and \\underline{x}(y, B): \n\\begin{aligned}\n  &u'(c_1(y, B, \\underline{x}(y, B))) - \\beta (1 + r) \\sum_{y'} Pr(y') \\frac{u'(c_1(y', B', \\underline{x}(y, B)))}{1 - \\nu_1(y', B', \\underline{x}(y, B))} = 0 \\\\\n  &u(c_2(y, B, \\underline{x}(y, B))) + \\beta \\sum_{y'} Pr(y') V_2^{h - 1}(y', B', \\underline{x}(y, B)) = U_2^{aut}(y),\n\\end{aligned}\n and update B'^h(y, B, \\underline{x}(y, B)) and \\underline{x}^h(y, B) with the solutions. The value functions are updated such that \n\\begin{aligned}\n  V_1^{h}(y, B, \\underline{x}(y, B)) &= u(c_1(y, B, \\underline{x}(y, B))) + \\beta \\sum_{y'} Pr(y') V_1^{h - 1}(y', B'^h(y, B, \\underline{x}(y, B)), \\underline{x}(y, B)) \\\\\n  V_2^{h}(y, B, \\underline{x}(y, B)) &= U_2^{aut}(y).\n\\end{aligned}\n\nFor x \\in [\\underline{x}(y, B), \\overline{x}(y, B)], where no participation constraint binds, first check if B' = 0 satisfied the planner’s Euler equation: \n  u'(c_1(y, B, x)) \\ge \\beta (1 + r) \\sum_{y'} Pr(y') \\frac{u'(c_1(y', 0, x))}{1 - \\nu_1(y', 0, x)}.\n If this is violated, I solve for B' such that the planner’s Euler equation holds with equality: \n  u'(c_1(y, B, x)) = \\beta (1 + r) \\sum_{y'} Pr(y') \\frac{u'(c_1(y', B', x))}{1 - \\nu_1(y', B', x)}.\n Then update B'^h(y, B, x) with the solution. The value functions are updated as follows: \n\\begin{aligned}\n  V_1^{h}(y, B, x) &= u(c_1(y, B, x)) + \\beta \\sum_{y'} Pr(y') V_1^{h - 1}(y', B'^h(y, B, x), x) \\\\\n  V_2^{h}(y, B, x) &= u(c_1(y, B, x)) + \\beta \\sum_{y'} Pr(y') V_1^{h - 1}(y', B'^h(y, B, x), x).\n\\end{aligned}\n\nFor x < \\underline{y, B}, update the policy functions and value functions in the following way (remember that these do not depend on x, as discussed in the modeling solution section above): \n\\begin{aligned}\n  V_1^{h}(y, B, x) &= V_1^h(y, B, \\underline{x}(y, B)) \\\\\n  V_2^{h}(y, B, x) &= U_2^{aut}(y) \\\\\n  B^h(y, B, x) &= B^h(y, B, \\underline{x}(y, B)).\n\\end{aligned}\n Similarly, for x > \\overline{y, B}, the policy functions and value functions are updated such that \n\\begin{aligned}\n  V_1^{h}(y, B, x) &= U_1^{aut}(y) \\\\\n  V_2^{h}(y, B, x) &= V_2^h(y, B, \\overline{x}(y, B)) \\\\\n  B^h(y, B, x) &= B^h(y, B, \\overline{x}(y, B)).\n\\end{aligned}"
  },
  {
    "objectID": "lc_storage_solution.html#numerical-solutions",
    "href": "lc_storage_solution.html#numerical-solutions",
    "title": "2  Risk sharing with limited commitment and storage: Numerical solution",
    "section": "2.2 Numerical solutions",
    "text": "2.2 Numerical solutions\n\n2.2.1 Global settings\n\npacman::p_load(\n  tidyverse,\n  nleqslv,\n  pracma,\n  tictoc\n)\n\n\nset.seed(123)\n\nnumStates <- 3\nnumRelativeParetoWeights <- 201\nbeta <- 0.8\nsigma <- 1\n\nincomeGridPointsHH1 <- c(0.353, 0.5, 0.647)\nincomeGridPointsHH2 <- 1 - incomeGridPointsHH1\naggregateIncomeGridPoints <- incomeGridPointsHH1 + incomeGridPointsHH2\n\nincomeTransitionProbVec <- rep(1 / 3, 3)\nincomeTransitionMatrix <- matrix(1 / 3, nrow = 3, ncol = 3)\n\nreturnOnStorage <- 0.02\n\n\ncalculateUtility <- function(cons, sigma) {\n  if (sigma != 1) {\n    utility = (cons^(1 - sigma) - 1) / (1 - sigma)\n  } else if (sigma == 1) {\n    utility = log(cons)\n  }\n  return(utility)\n}\ncalculateMarginalUtility <- function(cons, sigma) cons^(- sigma)\n\n\ncreateStorageGridPoints <- function(incomeGridPointsHH1) {\n  storageGridPoints <- seq(0, sqrt(max(incomeGridPointsHH1)), by = 1e-2)^2\n  numStorageGridPoints <- length(storageGridPoints)\n  return(list(storageGridPoints, numStorageGridPoints))\n}\n\n\ncreateRelativeParetoWeightGridPoints <- function(\n    returnOnStorage,\n    storageGridPoints,\n    incomeGridPointsHH1\n) {\n  maxRelativeParetoWeight <- (\n    (1 + (1 + returnOnStorage) * max(storageGridPoints)) / min(incomeGridPointsHH1) - 1\n  )\n  minRelativeParetoWeight <- 1 / maxRelativeParetoWeight\n  \n  relativeParetoWeightsGridPoints <- c(\n    seq(\n      minRelativeParetoWeight, 1,\n      by = (1 - minRelativeParetoWeight) / floor(numRelativeParetoWeights / 2)\n    ),\n    rev(1 / seq(\n      minRelativeParetoWeight, 1,\n      by = (1 - minRelativeParetoWeight) / floor(numRelativeParetoWeights / 2)\n    )[1:floor(numRelativeParetoWeights / 2)])\n  )\n  \n  return(relativeParetoWeightsGridPoints)\n  \n}\n\n\n\n2.2.2 Value at autarky with private storage\n\ncalculateEulerEquationDiffAutarky <- function(\n    consumption,\n    income,\n    storage,\n    beta,\n    sigma,\n    returnOnStorage,\n    incomeProb,\n    storageGridPoints,\n    consumptionAutarkyMatrix\n) {\n  \n  interpolatedConsumptionByIncome <- apply(\n    consumptionAutarkyMatrix,\n    1,\n    function(x) {\n      approx(\n        storageGridPoints,\n        x,\n        income + (1 + returnOnStorage) * storage - consumption,\n        rule = 2\n      )$y}\n  )\n  \n  return(\n    calculateMarginalUtility(consumption, sigma) - (\n      beta * (1 + returnOnStorage) * (\n        incomeProb %*% calculateMarginalUtility(interpolatedConsumptionByIncome, sigma)\n      )\n    )\n  )\n}\n\ninterpolateValueByIncome <- function(\n    consumption,\n    income,\n    storage,\n    valueAutarkyMatrix,\n    storageGridPoints,\n    returnOnStorage\n) {\n  return(\n    apply(\n      valueAutarkyMatrix,\n      1,\n      function(x) {\n        approx(\n          storageGridPoints,\n          x,\n          income + (1 + returnOnStorage) * storage - consumption,\n          rule = 2\n          )$y}\n      )     \n    )\n}\n\nupdateValueAutarky <- function(\n  consumption,\n  interpolatedValueByIncome,\n  incomeProb,\n  beta,\n  sigma\n) {\n  return(\n    (\n      calculateUtility(consumption, sigma)\n      + beta * (\n        incomeProb %*% interpolatedValueByIncome\n      )\n    )\n  )\n}\n\ncomputeConsumptionAutarky <- function(\n    returnOnStorage,\n    storageGridPoints,\n    incomeGridPoints,\n    beta,\n    sigma,\n    incomeProb,\n    numStates,\n    numStorageGridPoints,\n    iterationTol = 1e-8,\n    maxIteration = 100\n) {\n  \n  consumptionAutarkyMatrix <- outer(rep(1, numStates), (1 / beta - 1) * storageGridPoints) + 1e-8\n  consumptionAutarkyMatrixNew <- matrix(NA, nrow = numStates, numStorageGridPoints)\n\n  iter <- 1\n  diff <- 1\n  while ((diff > iterationTol) & (iter < maxIteration)) {\n    \n    for (stateIndex in seq(1, numStates)) {\n      for (storageIndex in seq(1, numStorageGridPoints)) {\n        \n        if (calculateEulerEquationDiffAutarky(\n            storageGridPoints[storageIndex] * (1 + returnOnStorage) + incomeGridPoints[stateIndex],\n            incomeGridPoints[stateIndex],\n            storageGridPoints[storageIndex],\n            beta,\n            sigma,\n            returnOnStorage,\n            incomeTransitionMatrix[stateIndex,],\n            storageGridPoints,\n            consumptionAutarkyMatrix\n        ) >= 0) {\n          consumptionAutarkyMatrixNew[stateIndex, storageIndex] <- (\n            storageGridPoints[storageIndex] * (1 + returnOnStorage) + incomeGridPoints[stateIndex]\n          )\n        } else {\n          consumptionAutarkyMatrixNew[stateIndex, storageIndex] <- uniroot(\n          function(x) {calculateEulerEquationDiffAutarky(\n            x,\n            incomeGridPoints[stateIndex],\n            storageGridPoints[storageIndex],\n            beta,\n            sigma,\n            returnOnStorage,\n            incomeTransitionMatrix[stateIndex, ],\n            storageGridPoints,\n            consumptionAutarkyMatrix\n            )},\n            c(\n              1e-12, \n              storageGridPoints[storageIndex] * (1 + returnOnStorage) + incomeGridPoints[stateIndex]\n              )\n          )$root\n        }\n      }\n    }\n    \n    diff <- max(abs(consumptionAutarkyMatrixNew - consumptionAutarkyMatrix))\n    consumptionAutarkyMatrix <- consumptionAutarkyMatrixNew\n    iter <- iter + 1\n  }\n  \n  return(consumptionAutarkyMatrix)\n}\n\ncomputeValueAutarky <- function(\n    consumptionAutarkyMatrix,\n    returnOnStorage,\n    storageGridPoints,\n    incomeGridPoints,\n    beta,\n    sigma,\n    incomeProb,\n    numStates,\n    numStorageGridPoints,\n    iterationTol = 1e-8,\n    maxIteration = 100\n) {\n  \n  valueAutarkyMatrix <- calculateUtility(consumptionAutarkyMatrix, sigma) / (1 - beta)\n  valueAutarkyMatrixNew <- matrix(NA, nrow = numStates, ncol = numStorageGridPoints)\n  \n  iter <- 1\n  diff <- 1\n  while ((diff > iterationTol) & (iter < maxIteration)) {\n    \n    for (stateIndex in seq(1, numStates)) {\n      for (storageIndex in seq(1, numStorageGridPoints)) {\n        \n        interpolatedValueByIncome <- interpolateValueByIncome(\n          consumptionAutarkyMatrix[stateIndex, storageIndex],\n          incomeGridPoints[stateIndex],\n          storageGridPoints[storageIndex],\n          valueAutarkyMatrix,\n          storageGridPoints,\n          returnOnStorage\n        )\n        valueAutarkyMatrixNew[stateIndex, storageIndex] <- updateValueAutarky(\n          consumptionAutarkyMatrix[stateIndex, storageIndex],\n          interpolatedValueByIncome,\n          incomeTransitionMatrix[stateIndex,],\n          beta,\n          sigma\n        ) %>% as.numeric\n      }\n    }\n    \n    diff <- max(abs(valueAutarkyMatrixNew - valueAutarkyMatrix))\n    valueAutarkyMatrix <- valueAutarkyMatrixNew\n    iter <- iter + 1\n    \n  }\n  \n  return(valueAutarkyMatrix)\n}\n\nsolveValueAutarky <- function(\n    returnOnStorage,\n    storageGridPoints,\n    incomeGridPoints,\n    beta,\n    sigma,\n    incomeProb,\n    numStates,\n    numStorageGridPoints\n) {\n  \n  consumptionAutarkyMatrix <- computeConsumptionAutarky(\n      returnOnStorage,\n      storageGridPoints,\n      incomeGridPoints,\n      beta,\n      sigma,\n      incomeProb,\n      numStates,\n      numStorageGridPoints\n  )\n  \n  valueAutarkyMatrix <- computeValueAutarky(\n      consumptionAutarkyMatrix,\n      returnOnStorage,\n      storageGridPoints,\n      incomeGridPoints,\n      beta,\n      sigma,\n      incomeProb,\n      numStates,\n      numStorageGridPoints\n  )\n  \n  valueAutarkyZeroPrivateSaving <- valueAutarkyMatrix[, 1]\n  \n  return(valueAutarkyZeroPrivateSaving)\n\n}\n\n\n\n2.2.3 Model with storage and limited commitment\n\ncalculateHH1Consumption <- function(\n  aggregateResources,\n  relativeParetoWeight,\n  sigma\n) {\n    aggregateResources / (1 + (relativeParetoWeight^(1 / sigma)))\n}\n\ncalculateHH2Consumption <- function(\n  aggregateResources,\n  relativeParetoWeight,\n  sigma\n) {\n  (\n    aggregateResources \n    - aggregateResources / (1 + (relativeParetoWeight^(1 / sigma)))\n  )\n}\n\n\ncalculateEulerEquationDiff <- function(\n    aggregateIncome,\n    currentStorage,\n    currentRelativeParetoWeight,\n    returnOnStorage,\n    nextPeriodStorage,\n    aggregateIncomeGridPoints,\n    relativeParetoWeightsGridPoints,\n    nextStorageArray,\n    relativeParetoWeightsBoundsArray,\n    incomeTransitionProbVec,\n    storageGridPoints,\n    numStates,\n    sigma,\n    beta\n) {\n  \n  nextRelativeParetoWeight <- map_dbl(\n    seq(1, numStates),\n    function(x) {\n      currentRelativeParetoWeight %>% \n        pmax(\n          approx(\n            storageGridPoints,\n            relativeParetoWeightsBoundsArray[1, x, ],\n            nextPeriodStorage,\n            rule = 2\n          )$y\n        ) %>% \n        pmin(\n          approx(\n            storageGridPoints,\n            relativeParetoWeightsBoundsArray[2, x, ],\n            nextPeriodStorage,\n            rule = 2\n          )$y\n        )\n    }\n  )\n  \n  nu <- (1 - (nextRelativeParetoWeight / currentRelativeParetoWeight)) %>% pmax(0)\n  \n  return(\n    calculateMarginalUtility(\n      calculateHH1Consumption(\n          aggregateIncome\n          + (1 + returnOnStorage) * currentStorage - nextPeriodStorage,\n          currentRelativeParetoWeight,\n          sigma\n        ),\n      sigma\n    ) - (\n      beta * (1 + returnOnStorage) * incomeTransitionProbVec %*% (\n        calculateMarginalUtility(\n          calculateHH1Consumption(\n            aggregateIncomeGridPoints \n            + (1 + returnOnStorage) * nextPeriodStorage \n            - map_dbl(\n              seq(1, numStates),\n              function(xx) interp2(\n                x = storageGridPoints,\n                y = relativeParetoWeightsGridPoints,\n                Z = nextStorageArray[xx, , ],\n                xp = nextPeriodStorage %>% \n                  pmin(max(storageGridPoints)) %>% \n                  pmax(min(storageGridPoints)),\n                yp = nextRelativeParetoWeight[xx] %>%\n                  pmin(max(relativeParetoWeightsGridPoints)) %>%\n                  pmax(min(relativeParetoWeightsGridPoints)),\n                method = \"linear\"\n                )\n              ),\n            nextRelativeParetoWeight,\n            sigma\n          ),\n          sigma\n        ) / (1 - nu)\n      ) %>% as.numeric \n    )\n  )\n}\n\ncalculateValue <- function(\n    aggregateIncome,\n    currentStorage,\n    currentRelativeParetoWeight,\n    returnOnStorage,\n    nextPeriodStorage,\n    relativeParetoWeightsGridPoints,\n    valueArray,\n    incomeTransitionProbVec,\n    storageGridPoints,\n    numStates,\n    sigma,\n    beta,\n    calculateHouseholdConsumption\n) {\n \n  return(\n    calculateUtility(\n      calculateHouseholdConsumption(\n        aggregateIncome\n          + (1 + returnOnStorage) * currentStorage\n          - nextPeriodStorage,\n        currentRelativeParetoWeight,\n        sigma\n      ) %>% pmax(1e-12)\n      , sigma\n    ) + (\n      beta \n      * incomeTransitionProbVec \n      %*% map_dbl(\n        seq(1, numStates),\n        function(xx) {interp2(\n            x = storageGridPoints,\n            y = relativeParetoWeightsGridPoints,\n            Z = valueArray[xx, , ],\n            xp = nextPeriodStorage %>% \n              pmin(max(storageGridPoints)) %>% \n              pmax(min(storageGridPoints)),\n            yp = currentRelativeParetoWeight %>% \n              pmin(max(relativeParetoWeightsGridPoints)) %>% \n              pmax(min(relativeParetoWeightsGridPoints)),\n            method = \"linear\"\n        )}\n        ) %>% as.numeric)\n  )\n}\n\ncalculatePCDiff <- function(\n    aggregateIncome,\n    currentStorage,\n    currentRelativeParetoWeight,\n    returnOnStorage,\n    nextPeriodStorage,\n    relativeParetoWeightsGridPoints,\n    valueArray,\n    valueAutarky,\n    incomeTransitionProbVec,\n    storageGridPoints,\n    numStates,\n    sigma,\n    beta,\n    calculateHouseholdConsumption\n) {\n    return(\n      calculateValue(\n        aggregateIncome,\n        currentStorage,\n        currentRelativeParetoWeight,\n        returnOnStorage,\n        nextPeriodStorage,\n        relativeParetoWeightsGridPoints,\n        valueArray,\n        incomeTransitionProbVec,\n        storageGridPoints,\n        numStates,\n        sigma,\n        beta,\n        calculateHouseholdConsumption\n        ) - valueAutarky\n    )\n}\n\n\nsolveLCWithStorage <- function(\n    beta,\n    sigma,\n    returnOnStorage,\n    numStates,\n    incomeGridPointsHH1,\n    incomeGridPointsHH2,\n    aggregateIncomeGridPoints,\n    incomeTransitionProbVec,\n    incomeTransitionMatrix\n) {\n  \n  storageGridPointList <- createStorageGridPoints(incomeGridPointsHH1)\n  storageGridPoints <- storageGridPointList[[1]]\n  numStorageGridPoints <- storageGridPointList[[2]]\n  \n  relativeParetoWeightsGridPoints <- createRelativeParetoWeightGridPoints(\n    returnOnStorage,\n    storageGridPoints,\n    incomeGridPointsHH1\n    )\n  \n  valueAutarkyHH1 <- solveValueAutarky(\n      returnOnStorage,\n      storageGridPoints,\n      incomeGridPointsHH1,\n      beta,\n      sigma,\n      incomeProb,\n      numStates,\n      numStorageGridPoints\n  )\n  \n  valueAutarkyHH2 <- solveValueAutarky(\n      returnOnStorage,\n      storageGridPoints,\n      incomeGridPointsHH2,\n      beta,\n      sigma,\n      incomeProb,\n      numStates,\n      numStorageGridPoints\n  )\n  \n  # Initial values for value functions:\n  # No next-period storage and full-risk sharing\n  consumptionOnRelativeParetoWeightAndStorageGridHH1 <- array(\n    NA, dim = c(numStates, numRelativeParetoWeights, numStorageGridPoints)\n    )\n  for (stateIndex in seq(1, numStates)) {\n    for (weightIndex in seq(1, numRelativeParetoWeights)) {\n      consumptionOnRelativeParetoWeightAndStorageGridHH1[stateIndex, weightIndex, ] <- (\n          calculateHH1Consumption(\n            aggregateIncomeGridPoints[stateIndex] + (1 + returnOnStorage) * storageGridPoints,\n            relativeParetoWeightsGridPoints[weightIndex],\n            sigma\n            )\n        )\n      }\n    }\n  consumptionOnRelativeParetoWeightAndStorageGridHH2 <- array(\n    NA, dim = c(numStates, numRelativeParetoWeights, numStorageGridPoints)\n    )\n  for (stateIndex in seq(1, numStates)) {\n    for (weightIndex in seq(1, numRelativeParetoWeights)) {\n      consumptionOnRelativeParetoWeightAndStorageGridHH2[stateIndex, weightIndex, ] <- (\n          aggregateIncomeGridPoints[stateIndex] + (1 + returnOnStorage) * storageGridPoints \n          - consumptionOnRelativeParetoWeightAndStorageGridHH1[stateIndex, weightIndex, ]\n        )\n    }\n  }\n  \n  valueArrayHH1 <- (\n    calculateUtility(consumptionOnRelativeParetoWeightAndStorageGridHH1, sigma) / (1 - beta)\n  )\n  valueArrayHH2 <- (\n    calculateUtility(consumptionOnRelativeParetoWeightAndStorageGridHH2, sigma) / (1 - beta)\n  )\n  valueArrayHH1New <- valueArrayHH1\n  valueArrayHH2New <- valueArrayHH2\n  \n  \n  # Initial values for interval bounds:\n  # equal allocation only\n  relativeParetoWeightsBoundsArray <- array(\n    1, dim = c(2, numStates, numStorageGridPoints)\n  )\n  relativeParetoWeightsBoundsArrayNew <- array(\n    NA, dim = c(2, numStates, numStorageGridPoints)\n  )\n  \n  # Initial values for next period storage:\n  # zero storage\n  nextStorageArray <- array(\n    0, dim = c(numStates, numRelativeParetoWeights, numStorageGridPoints)\n    )\n  nextStorageArrayNew <- array(\n    0, dim = c(numStates, numRelativeParetoWeights, numStorageGridPoints)\n    )\n  \n  diff <- 1\n  iter <- 1\n  while ((diff > 1e-4) & (iter < 120)) {\n    \n    for (stateIndex in seq(1, numStates)) {\n      for (storageIndex in seq(1, numStorageGridPoints)) {\n        \n        # (i) Find upper bound\n        if (\n          calculatePCDiff(\n                aggregateIncomeGridPoints[stateIndex],\n                currentStorage = storageGridPoints[storageIndex],\n                currentRelativeParetoWeight = max(relativeParetoWeightsGridPoints),\n                returnOnStorage,\n                nextPeriodStorage = 0,\n                relativeParetoWeightsGridPoints,\n                valueArray = valueArrayHH1,\n                valueAutarky = valueAutarkyHH1[stateIndex],\n                incomeTransitionProbVec,\n                storageGridPoints,\n                numStates,\n                sigma,\n                beta,\n                calculateHH1Consumption\n              ) > 0\n        ) {\n          relativeParetoWeightsUpperTmp <- max(relativeParetoWeightsGridPoints)\n        } else {\n          relativeParetoWeightsUpperTmp <- uniroot(\n            function(x) {\n              calculatePCDiff(\n                aggregateIncomeGridPoints[stateIndex],\n                currentStorage = storageGridPoints[storageIndex],\n                currentRelativeParetoWeight = x,\n                returnOnStorage,\n                nextPeriodStorage = 0,\n                relativeParetoWeightsGridPoints,\n                valueArray = valueArrayHH1,\n                valueAutarky = valueAutarkyHH1[stateIndex],\n                incomeTransitionProbVec,\n                storageGridPoints,\n                numStates,\n                sigma,\n                beta,\n                calculateHH1Consumption\n              )\n            },\n            c(min(relativeParetoWeightsGridPoints), max(relativeParetoWeightsGridPoints))\n          )$root\n        }\n        \n        if (\n          calculateEulerEquationDiff(\n            aggregateIncomeGridPoints[stateIndex],\n            storageGridPoints[storageIndex],\n            currentRelativeParetoWeight = relativeParetoWeightsUpperTmp,\n            returnOnStorage,\n            nextPeriodStorage = 0,\n            aggregateIncomeGridPoints,\n            relativeParetoWeightsGridPoints,\n            nextStorageArray,\n            relativeParetoWeightsBoundsArray,\n            incomeTransitionProbVec,\n            storageGridPoints,\n            numStates,\n            sigma,\n            beta\n            ) >= 0\n        ) {\n          nextStorageArrayNew[\n            stateIndex, \n            which.min(abs(\n              relativeParetoWeightsUpperTmp - relativeParetoWeightsGridPoints\n              )), \n            storageIndex\n            ] <- 0\n          relativeParetoWeightsBoundsArrayNew[2, stateIndex, storageIndex] <- relativeParetoWeightsUpperTmp\n        } else {\n          resSolve <- nleqslv(\n            c(0.5, 1),\n            function(x) {\n              nextPeriodStorage <- x[1]\n              relativeParetoWeightUpperBound <- x[2]\n              y <- numeric(2)\n              \n              y[1] <- calculateEulerEquationDiff(\n                aggregateIncomeGridPoints[stateIndex],\n                storageGridPoints[storageIndex],\n                currentRelativeParetoWeight = relativeParetoWeightUpperBound,\n                returnOnStorage,\n                nextPeriodStorage = nextPeriodStorage,\n                aggregateIncomeGridPoints,\n                relativeParetoWeightsGridPoints,\n                nextStorageArray,\n                relativeParetoWeightsBoundsArray,\n                incomeTransitionProbVec,\n                storageGridPoints,\n                numStates,\n                sigma,\n                beta\n                )\n              \n              y[2] <- calculatePCDiff(\n                aggregateIncomeGridPoints[stateIndex],\n                storageGridPoints[storageIndex],\n                currentRelativeParetoWeight = relativeParetoWeightUpperBound,\n                returnOnStorage,\n                nextPeriodStorage = nextPeriodStorage,\n                relativeParetoWeightsGridPoints,\n                valueArray = valueArrayHH1,\n                valueAutarky = valueAutarkyHH1[stateIndex],\n                incomeTransitionProbVec,\n                storageGridPoints,\n                numStates,\n                sigma,\n                beta,\n                calculateHH1Consumption\n                )\n              return(y)\n            }\n          )$x\n          nextStorageArrayNew[\n            stateIndex, \n            which.min(abs(\n              resSolve[2] - relativeParetoWeightsGridPoints\n              )), \n            storageIndex\n            ] <- resSolve[1]\n          relativeParetoWeightsBoundsArrayNew[2, stateIndex, storageIndex] <- resSolve[2]\n        }\n        \n        # (ii) Find lower bound\n        if (\n          calculatePCDiff(\n            aggregateIncomeGridPoints[stateIndex],\n            currentStorage = storageGridPoints[storageIndex],\n            currentRelativeParetoWeight = min(relativeParetoWeightsGridPoints),\n            returnOnStorage,\n            nextPeriodStorage = 0,\n            relativeParetoWeightsGridPoints,\n            valueArray = valueArrayHH2,\n            valueAutarky = valueAutarkyHH2[stateIndex],\n            incomeTransitionProbVec,\n            storageGridPoints,\n            numStates,\n            sigma,\n            beta,\n            calculateHH2Consumption\n          ) > 0\n        ) {\n          relativeParetoWeightsLowerTmp <- min(relativeParetoWeightsGridPoints)\n        } else {\n          relativeParetoWeightsLowerTmp <- uniroot(\n            function(x) {\n              calculatePCDiff(\n                aggregateIncomeGridPoints[stateIndex],\n                currentStorage = storageGridPoints[storageIndex],\n                currentRelativeParetoWeight = x,\n                returnOnStorage,\n                nextPeriodStorage = 0,\n                relativeParetoWeightsGridPoints,\n                valueArray = valueArrayHH2,\n                valueAutarky = valueAutarkyHH2[stateIndex],\n                incomeTransitionProbVec,\n                storageGridPoints,\n                numStates,\n                sigma,\n                beta,\n                calculateHH2Consumption\n              )\n            },\n            c(min(relativeParetoWeightsGridPoints), max(relativeParetoWeightsGridPoints))\n          )$root\n        }\n        \n        if (\n          calculateEulerEquationDiff(\n            aggregateIncomeGridPoints[stateIndex],\n            storageGridPoints[storageIndex],\n            currentRelativeParetoWeight = relativeParetoWeightsLowerTmp,\n            returnOnStorage,\n            nextPeriodStorage = 0,\n            aggregateIncomeGridPoints,\n            relativeParetoWeightsGridPoints,\n            nextStorageArray,\n            relativeParetoWeightsBoundsArray,\n            incomeTransitionProbVec,\n            storageGridPoints,\n            numStates,\n            sigma,\n            beta\n            ) >= 0\n        ) {\n          nextStorageArrayNew[\n            stateIndex, \n            which.min(abs(\n              relativeParetoWeightsLowerTmp - relativeParetoWeightsGridPoints\n              )), \n            storageIndex\n            ] <- 0\n          relativeParetoWeightsBoundsArrayNew[1, stateIndex, storageIndex] <- relativeParetoWeightsLowerTmp\n        } else {\n          resSolve <- nleqslv(\n            c(0.5, 1),\n            function(x) {\n              nextPeriodStorage <- x[1]\n              relativeParetoWeightLowerBound <- x[2]\n              y <- numeric(2)\n              \n              y[1] <- calculateEulerEquationDiff(\n                aggregateIncomeGridPoints[stateIndex],\n                storageGridPoints[storageIndex],\n                currentRelativeParetoWeight = relativeParetoWeightLowerBound,\n                returnOnStorage,\n                nextPeriodStorage = nextPeriodStorage,\n                aggregateIncomeGridPoints,\n                relativeParetoWeightsGridPoints,\n                nextStorageArray,\n                relativeParetoWeightsBoundsArray,\n                incomeTransitionProbVec,\n                storageGridPoints,\n                numStates,\n                sigma,\n                beta\n                )\n              \n              y[2] <- calculatePCDiff(\n                aggregateIncomeGridPoints[stateIndex],\n                storageGridPoints[storageIndex],\n                currentRelativeParetoWeight = relativeParetoWeightLowerBound,\n                returnOnStorage,\n                nextPeriodStorage = nextPeriodStorage,\n                relativeParetoWeightsGridPoints,\n                valueArray = valueArrayHH2,\n                valueAutarky = valueAutarkyHH2[stateIndex],\n                incomeTransitionProbVec,\n                storageGridPoints,\n                numStates,\n                sigma,\n                beta,\n                calculateHH2Consumption\n                )\n              \n              return(y)\n            }\n          )$x\n          nextStorageArrayNew[\n            stateIndex, \n            which.min(abs(\n              resSolve[2] - relativeParetoWeightsGridPoints\n              )), \n            storageIndex\n            ] <- resSolve[1]\n          relativeParetoWeightsBoundsArrayNew[1, stateIndex, storageIndex] <- resSolve[2]\n        }\n        \n        # (iii) Calculate values in between\n        relativeParetoWeightsLower <- relativeParetoWeightsBoundsArrayNew[1, stateIndex, storageIndex]\n        relativeParetoWeightsUpper <- relativeParetoWeightsBoundsArrayNew[2, stateIndex, storageIndex]\n        \n        relativeParetoWeightsLowerIndex <- which.min(\n          abs(relativeParetoWeightsGridPoints - relativeParetoWeightsLower)\n          )\n        relativeParetoWeightsUpperIndex <- which.min(\n          abs(relativeParetoWeightsGridPoints - relativeParetoWeightsUpper)\n          )\n        \n        for (weightIndex in seq(relativeParetoWeightsLowerIndex, relativeParetoWeightsUpperIndex)) {\n          \n          if (\n           calculateEulerEquationDiff(\n              aggregateIncomeGridPoints[stateIndex],\n              storageGridPoints[storageIndex],\n              relativeParetoWeightsGridPoints[weightIndex],\n              returnOnStorage,\n              nextPeriodStorage = 0,\n              aggregateIncomeGridPoints,\n              relativeParetoWeightsGridPoints,\n              nextStorageArray,\n              relativeParetoWeightsBoundsArray,\n              incomeTransitionMatrix[stateIndex,],\n              storageGridPoints,\n              numStates,\n              sigma,\n              beta\n          ) > 0) {\n            nextStorageArrayNew[stateIndex, weightIndex, storageIndex] <- 0\n            valueArrayHH1New[stateIndex, weightIndex, storageIndex] <- calculateValue(\n              aggregateIncomeGridPoints[stateIndex],\n              storageGridPoints[storageIndex],\n              currentRelativeParetoWeight = relativeParetoWeightsGridPoints[weightIndex],\n              returnOnStorage,\n              nextPeriodStorage = 0,\n              relativeParetoWeightsGridPoints,\n              valueArrayHH1,\n              incomeTransitionProbVec,\n              storageGridPoints,\n              numStates,\n              sigma,\n              beta,\n              calculateHH1Consumption\n              )\n            valueArrayHH2New[stateIndex, weightIndex, storageIndex] <- calculateValue(\n              aggregateIncomeGridPoints[stateIndex],\n              storageGridPoints[storageIndex],\n              currentRelativeParetoWeight = relativeParetoWeightsGridPoints[weightIndex],\n              returnOnStorage,\n              nextPeriodStorage = 0,\n              relativeParetoWeightsGridPoints,\n              valueArrayHH2,\n              incomeTransitionProbVec,\n              storageGridPoints,\n              numStates,\n              sigma,\n              beta,\n              calculateHH2Consumption\n              )\n          } else {\n            nextStorageArrayNew[stateIndex, weightIndex, storageIndex] <- uniroot(\n              function(x) {calculateEulerEquationDiff(\n                aggregateIncomeGridPoints[stateIndex],\n                storageGridPoints[storageIndex],\n                relativeParetoWeightsGridPoints[weightIndex],\n                returnOnStorage,\n                x,\n                aggregateIncomeGridPoints,\n                relativeParetoWeightsGridPoints,\n                nextStorageArray,\n                relativeParetoWeightsBoundsArray,\n                incomeTransitionMatrix[stateIndex,],\n                storageGridPoints,\n                numStates,\n                sigma,\n                beta\n                )},\n              c(\n                0, \n                aggregateIncomeGridPoints[stateIndex] \n                + (1 + returnOnStorage) * storageGridPoints[storageIndex] \n                - 1e-12\n                )\n              )$root\n            valueArrayHH1New[stateIndex, weightIndex, storageIndex] <- calculateValue(\n              aggregateIncomeGridPoints[stateIndex],\n              storageGridPoints[storageIndex],\n              currentRelativeParetoWeight = relativeParetoWeightsGridPoints[weightIndex],\n              returnOnStorage,\n              nextPeriodStorage = nextStorageArrayNew[stateIndex, weightIndex, storageIndex],\n              relativeParetoWeightsGridPoints,\n              valueArrayHH1,\n              incomeTransitionProbVec,\n              storageGridPoints,\n              numStates,\n              sigma,\n              beta,\n              calculateHH1Consumption\n              )\n            valueArrayHH2New[stateIndex, weightIndex, storageIndex] <- calculateValue(\n              aggregateIncomeGridPoints[stateIndex],\n              storageGridPoints[storageIndex],\n              currentRelativeParetoWeight = relativeParetoWeightsGridPoints[weightIndex],\n              returnOnStorage,\n              nextPeriodStorage = nextStorageArrayNew[stateIndex, weightIndex, storageIndex],\n              relativeParetoWeightsGridPoints,\n              valueArrayHH2,\n              incomeTransitionProbVec,\n              storageGridPoints,\n              numStates,\n              sigma,\n              beta,\n              calculateHH2Consumption\n              )\n          }\n        }\n          \n        # Values and policies outside the interval\n        nextStorageArrayNew[\n          stateIndex,\n          relativeParetoWeightsGridPoints > relativeParetoWeightsUpper,\n          storageIndex\n        ] <- nextStorageArrayNew[\n          stateIndex,\n          relativeParetoWeightsUpperIndex,\n          storageIndex\n        ]\n        valueArrayHH1New[\n          stateIndex,\n          relativeParetoWeightsGridPoints > relativeParetoWeightsUpper,\n          storageIndex\n        ] <- valueArrayHH1New[\n          stateIndex,\n          relativeParetoWeightsUpperIndex,\n          storageIndex\n        ]\n        valueArrayHH2New[\n          stateIndex,\n          relativeParetoWeightsGridPoints > relativeParetoWeightsUpper,\n          storageIndex\n        ] <- valueArrayHH2New[\n          stateIndex,\n          relativeParetoWeightsUpperIndex,\n          storageIndex\n        ]\n        \n        nextStorageArrayNew[\n          stateIndex,\n          relativeParetoWeightsGridPoints < relativeParetoWeightsLower,\n          storageIndex\n        ] <- nextStorageArrayNew[\n          stateIndex,\n          relativeParetoWeightsLowerIndex,\n          storageIndex\n        ]\n        valueArrayHH1New[\n          stateIndex,\n          relativeParetoWeightsGridPoints < relativeParetoWeightsLower,\n          storageIndex\n        ] <- valueArrayHH1New[\n          stateIndex,\n          relativeParetoWeightsLowerIndex,\n          storageIndex\n        ]\n        valueArrayHH2New[\n          stateIndex,\n          relativeParetoWeightsGridPoints < relativeParetoWeightsLower,\n          storageIndex\n        ] <- valueArrayHH2New[\n          stateIndex,\n          relativeParetoWeightsLowerIndex,\n          storageIndex\n        ]\n      }\n      \n    }\n    \n    diff <- max(c(\n      max(abs(valueArrayHH1New - valueArrayHH1)),\n      max(abs(valueArrayHH2New - valueArrayHH2))\n    ))\n    \n    relativeParetoWeightsBoundsArray <- relativeParetoWeightsBoundsArrayNew\n    nextStorageArray <- nextStorageArrayNew\n    valueArrayHH1 <- valueArrayHH1New\n    valueArrayHH2 <- valueArrayHH2New\n    iter <- iter + 1\n    \n  }\n  \n  return(\n    list(\n      valueArrayHH1 = valueArrayHH1,\n      valueArrayHH2 = valueArrayHH2,\n      nextStorageArray = nextStorageArray,\n      relativeParetoWeightsBoundsArray = relativeParetoWeightsBoundsArray\n    )\n  )\n}\n\n\nLCWithStorageResult <- solveLCWithStorage(\n    beta,\n    sigma,\n    returnOnStorage,\n    numStates,\n    incomeGridPointsHH1,\n    incomeGridPointsHH2,\n    aggregateIncomeGridPoints,\n    incomeTransitionProbVec,\n    incomeTransitionMatrix\n)\n\n\nsaveRDS(\n  LCWithStorageResult,\n  file.path('IntermediateData/modelSolution.rds')\n)\n\n\n\n\n\nÁbrahám, Árpád, and Sarolta Laczó. 2018. “Efficient Risk Sharing with Limited Commitment and Storage.” The Review of Economic Studies 85 (3): 1389–1424."
  },
  {
    "objectID": "lc_storage_simulation.html#storage-and-consumption-at-the-steady-state",
    "href": "lc_storage_simulation.html#storage-and-consumption-at-the-steady-state",
    "title": "3  Risk sharing with limited commitment and storage: Simulation",
    "section": "4.1 Storage and consumption at the steady state",
    "text": "4.1 Storage and consumption at the steady state\nFirst I show the storage and consumption at the steady state. The figures below show that, even in the steady state, they are stochastic. This is in contrast to the implication of a limited commitment model without storage, as in Kocherlakota (1996), where consumption in limit takes a finite number of values. Also, the stochastic consumption clearly shows the violation of the “amnesia” property in Kocherlakota (1996): consumption is not determined by the state and identities of households whose participation constraints are binding.\n\nsimulationResult %>% \n  filter(period >= 100) %>% \n  ggplot(aes(x = period, y = storage)) +\n  geom_point() +\n  xlab('Time period') +\n  ylab('Public storage') +\n  theme_classic()\n\n\n\nsimulationResult %>% \n  filter(period >= 100) %>% \n  ggplot(aes(x = period, y = consHH1)) +\n  geom_point() +\n  xlab('Time period') +\n  ylab('HH1 consumption') +\n  theme_classic()"
  },
  {
    "objectID": "lc_storage_simulation.html#relative-pareto-weight-intervals",
    "href": "lc_storage_simulation.html#relative-pareto-weight-intervals",
    "title": "3  Risk sharing with limited commitment and storage: Simulation",
    "section": "4.2 Relative Pareto weight intervals",
    "text": "4.2 Relative Pareto weight intervals\nThe figure below shows the interval bounds of relative Pareto weights, where the x-axis is public storage. It shows that when public storage is large, participation constraints are more relaxed and hence more transfers are achievable. This is exactly why the social planner has an incentive for saving: more public storage allows a better functionality of a risk-sharing network.\n\ntibble(\n  storage = storageGridPoints,\n  x_l_1 = relativeParetoWeightsBoundsArray[1,1,],\n  x_l_2 = relativeParetoWeightsBoundsArray[1,2,],\n  x_l_3 = relativeParetoWeightsBoundsArray[1,3,],\n  x_h_1 = relativeParetoWeightsBoundsArray[2,1,],\n  x_h_2 = relativeParetoWeightsBoundsArray[2,2,],\n  x_h_3 = relativeParetoWeightsBoundsArray[2,3,]\n) %>% \n  ggplot() +\n  geom_line(aes(x = storage, y = x_l_1, color = 'a')) +\n  geom_line(aes(x = storage, y = x_l_2, color = 'b')) +\n  geom_line(aes(x = storage, y = x_l_3, color = 'c')) +\n  geom_line(aes(x = storage, y = x_h_1, color = 'd')) +\n  geom_line(aes(x = storage, y = x_h_2, color = 'e')) +\n  geom_line(aes(x = storage, y = x_h_3, color = 'f')) +\n  scale_color_manual(\n      name = \"End-points\",\n      values = c(\n        \"blue\",\n        \"purple\",\n        \"brown\",\n        \"red\",\n        \"orange\",\n        \"gray\"\n        ),\n      labels = unname(TeX(c(\n        \"$\\\\underline{x}_1$\",\n        \"$\\\\underline{x}_2$\",\n        \"$\\\\underline{x}_3$\",\n        \"$\\\\bar{x}_1$\",\n        \"$\\\\bar{x}_2$\",\n        \"$\\\\bar{x}_3$\"\n        )))\n      ) +\n  theme_minimal() +\n  scale_y_log10() +\n  xlab('Public storage') + \n  ylab('Relative Pareto weight')"
  },
  {
    "objectID": "lc_storage_simulation.html#storage-behavior",
    "href": "lc_storage_simulation.html#storage-behavior",
    "title": "3  Risk sharing with limited commitment and storage: Simulation",
    "section": "4.3 Storage behavior",
    "text": "4.3 Storage behavior\nThis is not a simulation result, but let me know how the storage policy function looks differently by income states. The first is for the case where the relative Pareto weight is 1.\n\ntibble(\n  storage = storageGridPoints,\n  x1 = nextStorageArray[1,101,],\n  x2 = nextStorageArray[2,101,],\n  x3 = nextStorageArray[3,101,],\n) %>% \n  filter(storageGridPoints < 0.05) %>% \n  ggplot() +\n  geom_line(aes(x = storage, y = x1, color = 'a')) +\n  geom_line(aes(x = storage, y = x2, color = 'b')) +\n  geom_line(aes(x = storage, y = x3, color = 'c')) +\n  xlab(\"Current public storage\") +\n  ylab(\"Next-period public storage\") +\n  scale_color_manual(\n      name = \"Income states\",\n      values = c(\n        \"blue\",\n        \"red\",\n        \"orange\"\n        ),\n      labels = c(\n        \"Low HH1 income\",\n        \"Medium HH1 income\",\n        \"High HH1 income\"\n      )\n      ) +\n  theme_minimal()\n\n\n\n\nAnd this is the case where the relative Pareto weight is 0.64. Remember that a smaller relative Pareto weight is in favor of Household 1.\n\ntibble(\n  storage = storageGridPoints,\n  x1 = nextStorageArray[1,51,],\n  x2 = nextStorageArray[2,51,],\n  x3 = nextStorageArray[3,51,],\n) %>% \n  filter(storageGridPoints < 0.05) %>% \n  ggplot() +\n  geom_line(aes(x = storage, y = x1, color = 'a')) +\n  geom_line(aes(x = storage, y = x2, color = 'b')) +\n  geom_line(aes(x = storage, y = x3, color = 'c')) +\n  xlab(\"Current public storage\") +\n  ylab(\"Next-period public storage\") +\n  scale_color_manual(\n      name = \"Income states\",\n      values = c(\n        \"blue\",\n        \"red\",\n        \"orange\"\n        ),\n      labels = c(\n        \"Low HH1 income\",\n        \"Medium HH1 income\",\n        \"High HH1 income\"\n      )\n      ) +\n  theme_minimal()"
  },
  {
    "objectID": "lc_no_storage.html#code",
    "href": "lc_no_storage.html#code",
    "title": "4  Comparison: Risk sharing with limited commitment but without storage",
    "section": "4.1 Code",
    "text": "4.1 Code\n\npacman::p_load(\n  tidyverse,\n  kableExtra,\n  latex2exp\n)\n\n\n4.1.1 Utility functions\n\ncalculateUtility <- function(cons, sigma) {\n  if (sigma != 1) {\n    utility = (cons^(1 - sigma) - 1) / (1 - sigma)\n  } else if (sigma == 1) {\n    utility = log(cons)\n  }\n  return(utility)\n}\ncalculateMarginalUtility <- function(cons, sigma) cons^(- sigma)\n\n\n\n4.1.2 Consumption function\n\ncalculateHH1Consumption <- function(\n  aggregateResources,\n  relativeParetoWeight,\n  sigma\n) {\n    aggregateResources / (1 + (relativeParetoWeight^(1 / sigma)))\n}\n\n\n\n4.1.3 Value under autarky\n\ncalculateAutarkyValue <- function(\n    incomeGridPoints, \n    sigma,\n    delta,\n    punishment,\n    incomeTransitionMatrix\n) {\n  \n  autarkyValue <- numeric(length = length(incomeGridPoints))\n  i <- 1\n  diff <- 1\n  while (diff > 1e-12) {\n    autarkyValueNew <- (\n      calculateUtility(incomeGridPoints * (1 - punishment), sigma) \n      + delta * incomeTransitionMatrix %*% autarkyValue\n    )\n    diff <- max(abs(autarkyValueNew - autarkyValue))\n    autarkyValue <- autarkyValueNew\n    i <- i + 1\n  }\n  return(autarkyValue)\n}\n\n\ngetRelativeParetoWeightsGridPoints <- function(\n    sigma,\n    punishment,\n    householdIncomeGridPoints,\n    villageIncomeGridPoints,\n    numRelativeParetoWeights\n    ) {\n  \n  minRelativeParetoWeights <- (\n    calculateMarginalUtility(max(villageIncomeGridPoints), sigma) \n    / calculateMarginalUtility(min(householdIncomeGridPoints * (1 - punishment)), sigma)\n  )\n  maxRelativeParetoWeights <- (\n    calculateMarginalUtility(min(villageIncomeGridPoints * (1 - punishment)), sigma) \n    / calculateMarginalUtility(max(householdIncomeGridPoints), sigma)\n  )\n  relativeParetoWeightsGridPoints <- exp(\n    seq(\n      log(minRelativeParetoWeights), \n      log(maxRelativeParetoWeights), \n      length.out = numRelativeParetoWeights)\n    )\n  return(relativeParetoWeightsGridPoints)\n}\n\n\ncalculateHouseholdConsumption <- function(\n  aggregateIncome,\n  relativeParetoWeight,\n  numHouseholds,\n  sigma\n) {\n    aggregateIncome / (1 + (numHouseholds - 1) * (relativeParetoWeight^(- 1 / sigma)))\n}\n\n\ncalculateValueFullRiskSharing <- function(\n  incomeTransitionMatrix, \n  aggregateIncomeGridPoints, \n  delta, \n  sigma, \n  autarkyValueMatrix, \n  consumptionOnRelativeParetoWeightGrid,\n  numRelativeParetoWeights,\n  numHouseholds\n  ) {\n\n  # Initial guess is expected utilities under autarky\n  householdValueFullRiskSharing <- outer(\n    autarkyValueMatrix[, 1], rep(1, numRelativeParetoWeights)\n    )\n  villageValueFullRiskSharing <- outer(\n    autarkyValueMatrix[, 2], rep(1, numRelativeParetoWeights)\n    )\n\n  iteration <- 1\n  diff <- 1\n  while (diff > 1e-10 & iteration < 500) {\n    householdValueFullRiskSharingNew <- (\n      calculateUtility(consumptionOnRelativeParetoWeightGrid, sigma) \n      + delta * incomeTransitionMatrix %*% householdValueFullRiskSharing\n    )\n    villageValueFullRiskSharingNew <- (\n      calculateUtility(\n        (aggregateIncomeGridPoints - consumptionOnRelativeParetoWeightGrid) / (numHouseholds - 1), \n        sigma\n        ) \n      + delta * incomeTransitionMatrix %*% villageValueFullRiskSharing\n    )\n    \n    diff <- max(\n      max(abs(householdValueFullRiskSharing - householdValueFullRiskSharingNew)), \n      max(abs(villageValueFullRiskSharing - villageValueFullRiskSharingNew))\n      )\n    householdValueFullRiskSharing <- householdValueFullRiskSharingNew\n    villageValueFullRiskSharing <- villageValueFullRiskSharingNew\n    iteration <- iteration + 1\n    \n  }\n\n  return(list(\n    householdValueFullRiskSharing = householdValueFullRiskSharing, \n    villageValueFullRiskSharing = villageValueFullRiskSharing\n    ))\n}\n\n\ninterpolateValueFunction <- function(\n    relativeParetoWeight,\n    relativeParetoWeightsGridPoints,\n    valueFunctionMatrix\n    ) {\n  apply(\n    valueFunctionMatrix,\n    1,\n    function(x) {\n      approx(\n        relativeParetoWeightsGridPoints, \n        x, \n        relativeParetoWeight,\n        rule = 2\n        )$y\n    }\n    )\n}\n\ncalculateDiffLCRiskSharingAndAutarky <- function(\n    relativeParetoWeight,\n    relativeParetoWeightsGridPoints,\n    delta,\n    sigma,\n    aggregateIncome,\n    householdValueLCRiskSharing,\n    villageValueLCRiskSharing,\n    incomeTransitionProbVec,\n    householdAutarkyValue,\n    villageAutarkyValue,\n    numHouseholds\n    ) {\n  \n  householdConsumption <- calculateHouseholdConsumption(\n    aggregateIncome,\n    relativeParetoWeight,\n    numHouseholds,\n    sigma\n  )\n  \n  householdValueLCRiskSharingAtRelativeParetoWeight <- interpolateValueFunction(\n    relativeParetoWeight,\n    relativeParetoWeightsGridPoints,\n    householdValueLCRiskSharing\n    )\n  villageValueLCRiskSharingAtRelativeParetoWeight <- interpolateValueFunction(\n    relativeParetoWeight,\n    relativeParetoWeightsGridPoints,\n    villageValueLCRiskSharing\n    )\n  \n  householdDiffLCRiskSharingAndAutarky <- (\n    calculateUtility(householdConsumption, sigma) \n    + delta * incomeTransitionProbVec %*% householdValueLCRiskSharingAtRelativeParetoWeight \n    - householdAutarkyValue\n  ) %>% as.numeric\n  villageDiffLCRiskSharingAndAutarky <- (\n    calculateUtility((aggregateIncome - householdConsumption) / (numHouseholds - 1), sigma) \n    + delta * incomeTransitionProbVec %*% villageValueLCRiskSharingAtRelativeParetoWeight \n    - villageAutarkyValue\n  ) %>% as.numeric\n\n  return(list(\n    householdDiffLCRiskSharingAndAutarky = householdDiffLCRiskSharingAndAutarky,\n    villageDiffLCRiskSharingAndAutarky = villageDiffLCRiskSharingAndAutarky\n  ))\n}\n\n\ncalculateValueLCRiskSharing <- function(\n  valueFullRiskSharing,\n  consumptionOnRelativeParetoWeightGrid,\n  aggregateIncomeGridPoints,\n  incomeTransitionMatrix,\n  autarkyValueMatrix,\n  relativeParetoWeightsGridPoints,\n  numRelativeParetoWeights,\n  delta,\n  sigma,\n  numIncomeStates,\n  numHouseholds,\n  iterationLimit,\n  diffLimit\n) {\n  \n  # Initial guess is expected utilities under full risk sharing\n  householdValueLCRiskSharing <- valueFullRiskSharing$householdValueFullRiskSharing\n  villageValueLCRiskSharing <- valueFullRiskSharing$villageValueFullRiskSharing\n  \n  diff <- 1\n  iteration <- 1\n  while ((diff > diffLimit) && (iteration <= iterationLimit)) {\n    \n    # First, ignore enforceability and just update the value functions\n    # using the values at the previous iteration\n    householdValueLCRiskSharingNew <- (\n      calculateUtility(consumptionOnRelativeParetoWeightGrid, sigma) \n      + delta * incomeTransitionMatrix %*% householdValueLCRiskSharing\n    )\n    villageValueLCRiskSharingNew <- (\n      calculateUtility(\n        (aggregateIncomeGridPoints - consumptionOnRelativeParetoWeightGrid) / (numHouseholds - 1), \n        sigma\n        )\n      + delta * incomeTransitionMatrix %*% villageValueLCRiskSharing\n    )\n    \n    # Now check enforceability at each state\n    for (incomeStateIndex in seq(1, numIncomeStates)) {\n      householdAutarkyValue <- autarkyValueMatrix[incomeStateIndex, 1]\n      villageAutarkyValue <- autarkyValueMatrix[incomeStateIndex, 2]\n      \n      if (any(householdValueLCRiskSharingNew[incomeStateIndex, ] <= householdAutarkyValue)) {\n        villageValueLCRiskSharingNew[\n          incomeStateIndex,\n          householdValueLCRiskSharingNew[incomeStateIndex, ] <= householdAutarkyValue\n        ] <- villageValueLCRiskSharingNew[\n          incomeStateIndex,\n          householdValueLCRiskSharingNew[incomeStateIndex, ] <= householdAutarkyValue\n        ] %>% min\n        householdValueLCRiskSharingNew[\n          incomeStateIndex,\n          householdValueLCRiskSharingNew[incomeStateIndex, ] <= householdAutarkyValue\n        ] <- householdAutarkyValue\n      }\n      \n      if (any(villageValueLCRiskSharingNew[incomeStateIndex, ] <= villageAutarkyValue)) {\n        householdValueLCRiskSharingNew[\n          incomeStateIndex,\n          villageValueLCRiskSharingNew[incomeStateIndex, ] <= villageAutarkyValue\n        ] <- householdValueLCRiskSharingNew[\n          incomeStateIndex,\n          villageValueLCRiskSharingNew[incomeStateIndex, ] <= villageAutarkyValue\n        ] %>% min\n        villageValueLCRiskSharingNew[\n          incomeStateIndex,\n          villageValueLCRiskSharingNew[incomeStateIndex, ] <= villageAutarkyValue\n        ] <- villageAutarkyValue\n      }\n    }\n      \n    diff <- max(\n      max(abs(householdValueLCRiskSharingNew - householdValueLCRiskSharing)),\n      max(abs(villageValueLCRiskSharingNew - villageValueLCRiskSharing))\n    )\n    householdValueLCRiskSharing <- householdValueLCRiskSharingNew\n    villageValueLCRiskSharing <- villageValueLCRiskSharingNew\n    iteration <- iteration + 1\n  }\n  \n  relativeParetoWeightBounds <- matrix(NA, nrow = numIncomeStates, ncol = 2)\n  \n  for (incomeStateIndex in seq(1, numIncomeStates)) {\n    aggregateIncome <- aggregateIncomeGridPoints[incomeStateIndex]\n    incomeTransitionProbVec <- incomeTransitionMatrix[incomeStateIndex,]\n    householdAutarkyValue <- autarkyValueMatrix[incomeStateIndex, 1]\n    villageAutarkyValue <- autarkyValueMatrix[incomeStateIndex, 2]\n\n    if (\n      calculateDiffLCRiskSharingAndAutarky(\n        min(relativeParetoWeightsGridPoints),\n        relativeParetoWeightsGridPoints,\n        delta,\n        sigma,\n        aggregateIncome,\n        householdValueLCRiskSharing,\n        villageValueLCRiskSharing,\n        incomeTransitionProbVec,\n        householdAutarkyValue,\n        villageAutarkyValue,\n        numHouseholds\n        )$householdDiffLCRiskSharingAndAutarky < 0) {\n        relativeParetoWeightLowerBound <- uniroot(\n          function(x) {calculateDiffLCRiskSharingAndAutarky(\n          x,\n          relativeParetoWeightsGridPoints,\n          delta,\n          sigma,\n          aggregateIncome,\n          householdValueLCRiskSharing,\n          villageValueLCRiskSharing,\n          incomeTransitionProbVec,\n          householdAutarkyValue,\n          villageAutarkyValue,\n          numHouseholds\n          )$householdDiffLCRiskSharingAndAutarky}, \n        c(min(relativeParetoWeightsGridPoints), max(relativeParetoWeightsGridPoints)), \n        tol = 1e-10, \n        maxiter = 300\n        )$root\n        } else {\n          relativeParetoWeightLowerBound <- min(relativeParetoWeightsGridPoints)\n        }\n    \n    if (\n      calculateDiffLCRiskSharingAndAutarky(\n        max(relativeParetoWeightsGridPoints),\n        relativeParetoWeightsGridPoints,\n        delta,\n        sigma,\n        aggregateIncome,\n        householdValueLCRiskSharing,\n        villageValueLCRiskSharing,\n        incomeTransitionProbVec,\n        householdAutarkyValue,\n        villageAutarkyValue,\n        numHouseholds\n        )$villageDiffLCRiskSharingAndAutarky < 0) {\n        relativeParetoWeightUpperBound <- uniroot(\n          function(x) {calculateDiffLCRiskSharingAndAutarky(\n          x,\n          relativeParetoWeightsGridPoints,\n          delta,\n          sigma,\n          aggregateIncome,\n          householdValueLCRiskSharing,\n          villageValueLCRiskSharing,\n          incomeTransitionProbVec,\n          householdAutarkyValue,\n          villageAutarkyValue,\n          numHouseholds\n          )$villageDiffLCRiskSharingAndAutarky}, \n        c(min(relativeParetoWeightsGridPoints), max(relativeParetoWeightsGridPoints)), \n        tol = 1e-10, \n        maxiter = 300\n        )$root\n        } else {\n          relativeParetoWeightUpperBound <- max(relativeParetoWeightsGridPoints)\n        }\n        relativeParetoWeightBounds[incomeStateIndex, 1] <- relativeParetoWeightLowerBound\n        relativeParetoWeightBounds[incomeStateIndex, 2] <- relativeParetoWeightUpperBound\n        }\n\n  if (iteration == iterationLimit) {\n    print(\"Reached the maximum limit of iterations!\")\n  }\n  \n  return(list(\n    householdValueLCRiskSharing = householdValueLCRiskSharing,\n    villageValueLCRiskSharing = villageValueLCRiskSharing,\n    relativeParetoWeightBounds = relativeParetoWeightBounds))\n}\n\n\nsolveLCRiskSharing <- function(\n    delta,\n    sigma,\n    punishment,\n    householdIncomeGridPoints,\n    villageIncomeGridPoints,\n    incomeTransitionMatrix,\n    incomeGridPointsMatrix,\n    numIncomeStates,\n    numHouseholds,\n    numRelativeParetoWeights = 2000,\n    iterationLimit = 100,\n    diffLimit = 1e-8\n) {\n  \n  aggregateIncomeGridPoints <- (\n    incomeGridPointsMatrix[, 1] + incomeGridPointsMatrix[, 2] * (numHouseholds - 1)\n  )\n  \n  autarkyValueMatrix <- cbind(\n    calculateAutarkyValue(\n      householdIncomeGridPoints,\n      sigma,\n      delta,\n      punishment,\n      incomeTransitionMatrix\n    ),\n    calculateAutarkyValue(\n      villageIncomeGridPoints,\n      sigma,\n      delta,\n      punishment,\n      incomeTransitionMatrix\n    )\n  )\n  \n  relativeParetoWeightsGridPoints <- getRelativeParetoWeightsGridPoints(\n      sigma,\n      punishment,\n      householdIncomeGridPoints,\n      villageIncomeGridPoints,\n      numRelativeParetoWeights\n      )\n  \n  consumptionOnRelativeParetoWeightGrid <- matrix(\n    NA, nrow = numIncomeStates, ncol = numRelativeParetoWeights\n    )\n  for (incomeStateIndex in seq_along(aggregateIncomeGridPoints)) {\n    for (relativeParetoWeightIndex in seq_along(relativeParetoWeightsGridPoints)) {\n      consumptionOnRelativeParetoWeightGrid[\n        incomeStateIndex, \n        relativeParetoWeightIndex\n        ] <- calculateHouseholdConsumption(\n          aggregateIncomeGridPoints[incomeStateIndex],\n          relativeParetoWeightsGridPoints[relativeParetoWeightIndex],\n          numHouseholds,\n          sigma\n        )\n      }\n    }\n\n  valueFullRiskSharing <- calculateValueFullRiskSharing(\n    incomeTransitionMatrix, \n    aggregateIncomeGridPoints, \n    delta, \n    sigma, \n    autarkyValueMatrix, \n    consumptionOnRelativeParetoWeightGrid,\n    numRelativeParetoWeights,\n    numHouseholds\n    )\n\n  valueLCRiskSharing <- calculateValueLCRiskSharing(\n    valueFullRiskSharing,\n    consumptionOnRelativeParetoWeightGrid,\n    aggregateIncomeGridPoints,\n    incomeTransitionMatrix,\n    autarkyValueMatrix,\n    relativeParetoWeightsGridPoints,\n    numRelativeParetoWeights,\n    delta,\n    sigma,\n    numIncomeStates,\n    numHouseholds,\n    iterationLimit,\n    diffLimit\n  )\n\n  return(valueLCRiskSharing)\n}\n\n\nsigma <- 1.0\npunishment <- 0.0\n\ndelta <- 0.8\nsigma <- 1\nnumHouseholds <- 2\nnumIncomeStates <- 3\n\nincomeGridPointsHH1 <- c(0.353, 0.5, 0.647)\nincomeGridPointsHH2 <- 1 - incomeGridPointsHH1\nincomeGridPointsMatrix <- cbind(incomeGridPointsHH1, incomeGridPointsHH2)\naggregateIncomeGridPoints <- incomeGridPointsHH1 + incomeGridPointsHH2\n\nincomeTransitionMatrix <- matrix(1 / 3, nrow = 3, ncol = 3)\n\n\nLCRiskSharingNoStorageResult <- solveLCRiskSharing(\n    delta,\n    sigma,\n    punishment,\n    incomeGridPointsHH1,\n    incomeGridPointsHH2,\n    incomeTransitionMatrix,\n    incomeGridPointsMatrix,\n    numIncomeStates,\n    numHouseholds,\n    numRelativeParetoWeights = 10000,\n    iterationLimit = 1000,\n    diffLimit = 1e-8\n    )\n\n\nset.seed(123)\nsimSize <- 5000\nincomeSeq <- sample(seq(1, numIncomeStates), size = simSize, replace = TRUE)\n\nrelativeParetoWeightSeqNoStorage <- c(1)\nconsHH1SeqNoStorage <- c()\n\nfor (i in seq(1, simSize)) {\n  relativeParetoWeightSeqNoStorage <- c(\n    relativeParetoWeightSeqNoStorage,\n    relativeParetoWeightSeqNoStorage[i] %>% \n      pmax(\n        LCRiskSharingNoStorageResult$relativeParetoWeightBounds[\n          incomeSeq[i],\n          1\n        ]\n      ) %>% \n      pmin(\n        LCRiskSharingNoStorageResult$relativeParetoWeightBounds[\n          incomeSeq[i],\n          2\n        ]\n      )\n  )\n  \n  consHH1SeqNoStorage <- c(\n    consHH1SeqNoStorage,\n    calculateHH1Consumption(\n      (aggregateIncomeGridPoints[incomeSeq[i]]),\n      relativeParetoWeightSeqNoStorage[i + 1],\n      sigma\n    )\n  )\n}\n\nsimulationResultNoStorage <- tibble(\n  period = seq(1, simSize),\n  income = incomeSeq,\n  consHH1 = consHH1SeqNoStorage\n) %>% \n  mutate(\n    previousIncome = lag(income),\n    changeIncome = paste(as.character(previousIncome), '->', as.character(income))\n    )"
  },
  {
    "objectID": "lc_no_storage.html#comparison-with-the-case-with-storage",
    "href": "lc_no_storage.html#comparison-with-the-case-with-storage",
    "title": "4  Comparison: Risk sharing with limited commitment but without storage",
    "section": "4.3 Comparison with the case with storage",
    "text": "4.3 Comparison with the case with storage\nThe table below compares the consumption means, standard deviations, and the average utilities over time. Due to the storage with positive return on saving, the mean consumption is higher in the model with storage. However, due to the existence of storage, the autarky values are higher, and hence the risk-sharing functionality is degraded. This results in more variable consumption (second row) and hence, lower welfare (third row) in the model with storage. Notice that, this kind of reduced welfare is achieved only for medium-level returns on saving. If the return is too low, saving is not used and there is no welfare impact, and if the return is sufficiently high, the benefit from intertemporal consumption smoothing dominates and hence there is a welfare improvement.\n\nsimulationResult <- readRDS(\n  file.path('IntermediateData/simulationResult.rds')\n)\n\n\nsummaryTable <- cbind(\n  c(\n    (simulationResult %>% filter(period >= 100) %>% .$consHH1) %>% mean,\n    (simulationResult %>% filter(period >= 100) %>% .$consHH1) %>% sd,\n    log(simulationResult %>% filter(period >= 100) %>% .$consHH1) %>% mean\n  ),\n  c(\n    (simulationResultNoStorage %>% filter(period >= 100) %>% .$consHH1) %>% mean,\n    (simulationResultNoStorage %>% filter(period >= 100) %>% .$consHH1) %>% sd,\n    log(simulationResultNoStorage %>% filter(period >= 100) %>% .$consHH1) %>% mean\n  )\n) \n\nrownames(summaryTable) <- c(\"Mean Cons.\", \"SD Cons\", \"Mean Util.\")\ncolnames(summaryTable) <- c(\"With storage\", \"Without storage\")\n\nsummaryTable %>% \n  kbl(digits = 4) %>% \n  kable_classic()\n\n\n\n \n  \n      \n    With storage \n    Without storage \n  \n \n\n  \n    Mean Cons. \n    0.5009 \n    0.4992 \n  \n  \n    SD Cons \n    0.0863 \n    0.0717 \n  \n  \n    Mean Util. \n    -0.7067 \n    -0.7053"
  },
  {
    "objectID": "lc_no_storage.html#references",
    "href": "lc_no_storage.html#references",
    "title": "4  Comparison: Risk sharing with limited commitment but without storage",
    "section": "4.4 References",
    "text": "4.4 References\n\n\n\n\nKocherlakota, N. R. 1996. “Implications of Efficient Risk Sharing without Commitment.” The Review of Economic Studies 63 (4): 595–609. https://doi.org/10.2307/2297795.\n\n\nLigon, Ethan, Jonathan P. Thomas, and Tim Worrall. 2002. “Informal Insurance Arrangements with Limited Commitment: Theory and Evidence from Village Economies.” Review of Economic Studies 69 (1): 209–44. https://doi.org/10.1111/1467-937X.00204."
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "Risk-sharing with limited commitment and storage",
    "section": "References",
    "text": "References\n\n\n\n\nÁbrahám, Árpád, and Sarolta Laczó. 2018. “Efficient Risk Sharing with Limited Commitment and Storage.” The Review of Economic Studies 85 (3): 1389–1424.\n\n\nLigon, Ethan, Jonathan P. Thomas, and Tim Worrall. 2002. “Informal Insurance Arrangements with Limited Commitment: Theory and Evidence from Village Economies.” Review of Economic Studies 69 (1): 209–44. https://doi.org/10.1111/1467-937X.00204."
  },
  {
    "objectID": "lc_storage_model.html#transition-of-the-states",
    "href": "lc_storage_model.html#transition-of-the-states",
    "title": "1  Risk sharing with limited commitment and storage: Model",
    "section": "1.2 Transition of the states",
    "text": "1.2 Transition of the states\nFirst I review the solutions (policy functions and value functions) of the model and see how the states evolve in the model. In this document, I define the relative Pareto weight, x, as x \\equiv \\frac{u'(c_1)}{u'(c_2)}, which implies that higher x is in favor of Household 2. For policy functions, I consider x'(y, B, x), a current relative Pareto weight, B'(y, B, x), a next-period storage, and (\\underline{x}(y, B), \\overline{x}(y, B)), a interval specific to a state-storage pair. Note that \n  x'(y, B, x) = \\begin{cases}\n    \\overline{x}(y, B) \\quad &\\text{if } x \\ge \\overline{x}(y, B) \\\\\n    x \\quad &\\text{if } x \\in (\\underline{x}(y, B), \\overline{x}(y, B)) \\\\\n    \\underline{x}(y, B) \\quad &\\text{if } x \\le \\underline{x}(y, B).\n  \\end{cases}\n Individual value functions are denoted as V_1(y, B, x) and V_2(y, B, x).\nBy the intratemporal optimality conditions \n\\begin{aligned}\n  c_1(y, B, x) &= \\frac{y + (1 + r)B - B'(y, B, x)}{1 + x'(y, B, x)} \\\\\n  c_2(y, B, x) &= \\frac{y + (1 + r)B - B'(y, B, x)}{1 + 1 / x'(y, B, x)},\n\\end{aligned}\n and \n  \\nu_1(y, B, x) = \\max \\left\\{ 1 - \\frac{x'(y, B, x)}{x}, 0 \\right\\}.\n Note that \\nu_1 is not 0 when participation constraint of Household 1 binds.\nFor each (y, B), consider the following cases:\n\n1.2.1 Case 1: x < \\underline{x}(y, B)\nBy the update rule of the relative Pareto weight, x' = \\underline{x}(y, B). Since the participation constraint of Household 2 is binding, \n  u(c_2(y, B, x)) + \\beta \\sum_{y'} Pr(y') V_2(y', B'(y, B, x), \\underline{x}) = U_2^{aut}(y) \\quad \\left( = V_2(y, B, x) \\right),\n and the planner’s Euler equation is \n  u'(c_1(y, B, x)) \\ge \\beta (1 + r) \\sum_{y'} Pr(y') \\frac{u'(c_1(y', B'(y, B, x), \\underline{x}(y, B)))}{1 - \\nu_1(y', B'(y, B, x), \\underline{x}(y, B))}.\n Note that, in this case, B'(y, B, x) does not depend on x: if you look at the binding participation constraint of Household 2, since x is updated to \\underline{x}(y, B), the consumption c_2 does not depend on x, and since the right-hand side of the equation does not depend on x, the value function term should not depend on x either. Or, an alternative way to argue this is to refer to Lemma 1 of Ábrahám and Laczó (2018) stating that the current x is a sufficient statistic for B', given B (and actually y too because I consider a more general case that the aggregate income can differ across states).\nThe value function of Household 1 is \n  V_1(y, B, x) = u(c_1(y, B, x)) + \\beta \\sum_{y'} Pr(y') V_1(y', B'(y, B, x), \\underline{x}(y, B)).\n Notice that this also does not depend on x since c_1 and B' do not depend on x.\n\n\n1.2.2 Case 2: x = \\underline{x}(y, B)\nBy the update rule of the relative Pareto weight, x' = \\underline{x}(y, B). Since the participation constraint of Household 2 is binding, \n  u(c_2(y, B, \\underline{x}(y, B))) + \\beta \\sum_{y'} Pr(y') V_2(y', B'(y, B, \\underline{x}(y, B)), \\underline{x}) = U_2^{aut}(y) \\quad \\left( = V_2(y, B, \\underline{x}(y, B)) \\right),\n and the planner’s Euler equation is \n  u'(c_1(y, B, \\underline{x}(y, B))) \\ge \\beta (1 + r) \\sum_{y'} Pr(y') \\frac{u'(c_1(y', B'(y, B, \\underline{x}(y, B)), \\underline{x}(y, B)))}{1 - \\nu_1(y', B'(y, B, \\underline{x}(y, B)), \\underline{x}(y, B))}.\n The value function of Household 1 is \n  V_1(y, B, \\underline{x}(y, B)) = u(c_1(y, B, \\underline{x}(y, B))) + \\beta \\sum_{y'} Pr(y') V_1(y', B'(y, B, \\underline{x}(y, B)), \\underline{x}(y, B)).\n\n\n\n1.2.3 Case 3: x \\in (\\underline{x}(y, B), \\overline{x}(y, B)\nSince no participation constraint is binding in this case, x' = x. Therefore, the value functions of the households are \n\\begin{aligned}\n  V_1(y, B, x) &= u(c_1(y, B, x)) + \\beta \\sum_{y'} Pr(y') V_1(y', B'(y, B, x), x) \\\\\n  V_2(y, B, x) &= u(c_2(y, B, x)) + \\beta \\sum_{y'} Pr(y') V_2(y', B'(y, B, x), x).\n\\end{aligned}\n And the planner’s Euler equation needs to be satisfied: \n  u'(c_1(y, B, x)) \\ge \\beta (1 + r) \\sum_{y'} Pr(y') \\frac{u'(c_1(y', B'(y, B, x), x))}{1 - \\nu_1(y', B'(y, B, x), x)}.\n\n\n\n1.2.4 Case 4: x = \\overline{x}(y, B)\nBy the update rule of the relative Pareto weight, x' = \\overline{x}(y, B). Since the participation constraint of Household 1 is binding, \n  u(c_1(y, B, \\overline{x}(y, B))) + \\beta \\sum_{y'} Pr(y') V_1(y', B'(y, B, \\overline{x}(y, B)), \\overline{x}) = U_1^{aut}(y) \\quad \\left( = V_1(y, B, \\overline{x}(y, B)) \\right),\n and the planner’s Euler equation is \n  u'(c_1(y, B, \\overline{x}(y, B))) \\ge \\beta (1 + r) \\sum_{y'} Pr(y') \\frac{u'(c_1(y', B'(y, B, \\overline{x}(y, B)), \\overline{x}(y, B)))}{1 - \\nu_1(y', B'(y, B, \\overline{x}(y, B)), \\overline{x}(y, B))}.\n The value function of Household 2 is \n  V_2(y, B, \\overline{x}(y, B)) = u(c_2(y, B, \\overline{x}(y, B))) + \\beta \\sum_{y'} Pr(y') V_2(y', B'(y, B, \\overline{x}(y, B)), \\overline{x}(y, B)).\n\n\n\n1.2.5 Case 5: x < \\overline{x}(y, B)\nBy the update rule of the relative Pareto weight, x' = \\overline{x}(y, B). Since the participation constraint of Household 1 is binding, \n  u(c_1(y, B, x)) + \\beta \\sum_{y'} Pr(y') V_1(y', B'(y, B, x), \\overline{x}) = U_1^{aut}(y) \\quad \\left( = V_1(y, B, x) \\right),\n and the planner’s Euler equation is \n  u'(c_1(y, B, x)) \\ge \\beta (1 + r) \\sum_{y'} Pr(y') \\frac{u'(c_1(y', B'(y, B, x), \\overline{x}(y, B)))}{1 - \\nu_1(y', B'(y, B, x), \\overline{x}(y, B))}.\n The value function of Household 2 is \n  V_2(y, B, x) = u(c_2(y, B, x)) + \\beta \\sum_{y'} Pr(y') V_2(y', B'(y, B, x), \\overline{x}(y, B)).\n As in Case 1, B', V_1, and V_2 do not depend on x."
  },
  {
    "objectID": "lc_storage_model.html#references",
    "href": "lc_storage_model.html#references",
    "title": "1  Risk sharing with limited commitment and storage: Model",
    "section": "1.3 References",
    "text": "1.3 References\n\n\n\n\nÁbrahám, Árpád, and Sarolta Laczó. 2018. “Efficient Risk Sharing with Limited Commitment and Storage.” The Review of Economic Studies 85 (3): 1389–1424.\n\n\nLigon, Ethan, Jonathan P. Thomas, and Tim Worrall. 2002. “Informal Insurance Arrangements with Limited Commitment: Theory and Evidence from Village Economies.” Review of Economic Studies 69 (1): 209–44. https://doi.org/10.1111/1467-937X.00204.\n\n\nMarcet, Albert, and Ramon Marimon. 2019. “Recursive Contracts.” Econometrica 87 (5): 1589–1631."
  },
  {
    "objectID": "lc_storage_model.html#set-up",
    "href": "lc_storage_model.html#set-up",
    "title": "1  Risk sharing with limited commitment and storage: Model",
    "section": "1.1 Set up",
    "text": "1.1 Set up\n\n1.1.1 Model\nAs in the basic limited commitment model, a social planner maximized the discounted sum of utilities of households, subject to resource constraints and participation constraints. But now, the social planner is allowed to publicly save resources across times, and also, each household can privately save for future periods. Here,\n\npublic storage is observed by households, and households cannot access once they leave the risk-sharing network (hence the public storage does not affect the autarky value), and\nprivate storage is unenforceable in that social planners cannot use the private storage for resource allocation, and also, households can access the private storage under autarky too.\n\nHence, the social planner solves the following maximization problem. \n\\begin{aligned}\n  &\\max_{\\{c_{it}(s^t)\\}} \\sum_i \\lambda_i \\sum_{t = 1}^{\\infty} \\sum_{s^t} \\delta^t \\pi(s^t) u(c_{it}(s^t)) \\\\\n  \\text{subject to}\n  &\\sum_i c_{it} (s^t) \\le \\sum_i y_{it}(s_t) + (1+r) B \\left(s^{t - 1} \\right) - B\\left(s^t \\right)\\quad \\forall s^t, \\forall t \\\\\n  &\\sum_{r = t}^{\\infty} \\sum_{s^r} \\delta^{r - t} \\pi(s^r | s^t) u(c_{ir}(s^r)) \\ge \\tilde{U}_{i}^{aut}(s_t) \\quad \\forall s^t, \\forall t, \\forall i, \\\\\n  &B(s^t) \\ge 0 \\quad \\forall s^t, \\forall t\n\\end{aligned}\n where the similar notations are used as in the case without storage, with a few exceptions that, B(s^t) is a public storage at the state history s^t, and \\tilde{U}_i^{aut} is the autarky value with private storage. Also, for simplicity, assume that the income process is i.i.d..\nNote that, here I do not consider the possibility of households relying on private storage while they are in the risk-sharing network. In principle, they can use private saving, and hence to the list of constraints, I would need to add intertemporal optimality conditions (that is, Euler equations of each household). However, Ábrahám and Laczó (2018) shows that private storage does not matter when public asset accumulation is optimal (Proposition 4). Therefore, I can safely ignore the possibility of private storage from the constraints, which simplifies the expression and also numerical solution greatly.\nUsing the recursive form in Marcet and Marimon (2019), the Lagrangian can be written as \n\\begin{aligned}\n  \\mathcal{L} = \\sum_{t = 1}^{\\infty} \\sum_{s^t} \\beta^t Pr(s^t) \\left\\{ \\sum_i \\left[ M_i(s^t) u(c_i(s^t)) - \\mu_i(s^t) U^{aut}_i(s^t) \\right] + \\gamma(s^t) \\left( \\sum_i (y_i(s_t) - c_i(s^t)) + (1 + r) B(s^{t - 1}) - B(s^t) \\right) + \\rho(s^t) B(s^t) \\right\\},\n\\end{aligned}\n where \\mu_i(s^t), \\gamma(s^t), and \\rho(s^t) are Lagrangian multipliers of participation constraints, the resource constraint, and the non-negativity constraint of public storage, respectively. The variable, M_i(s^t), captures the evolution of the Pareto weights, and it evolves as M_i(s^t) = M_i(s^{t - 1}) + \\mu_i(s^t).\nThe first-order conditions are \n  M_i(s^t) u'(c_i(s^t)) = \\gamma(s^t) \\quad \\forall i,\n which implies that, for any two households, i and j, the following holds: \n  \\frac{u'(c_i(s^t))}{u'(c_j(s^t))} = \\frac{M_j(s^t)}{M_i(s^t)}.\n\nFrom now on, I consider the case where there are two households in a village. Letting x(s^t) \\equiv \\frac{M_2(s^t)}{M_1(s^t)}, I obtain \n  x(s^t) = \\frac{u'(c_1(s^t))}{u'(c_2(s^t))}.\n Defining, \\nu_i(s^t) = \\frac{\\mu_i(s^t)}{M_i(s^t)} for i = 1, 2, I obtain \n  x(s^t) = x(s^{t - 1}) \\frac{M_1(s^{t - 1})}{M_2(s^{t - 1})} \\frac{M_2(s^t)}{M_1(s^t)} = x(s^{t - 1}) \\frac{(M_1(s^t) - \\mu_1(s^t)) / M_1(s^t)}{(M_2(s^t) - \\mu_2(s^t)) / M_2(s^t)} = x(s^{t - 1}) \\frac{1 - \\nu_1(s^t)}{1 - \\nu_2(s^t)}.\n\nBy taking a derivative with respect to B(s^{t + 1}), I get the planner’s Euler equation as \n\\begin{aligned}\n  &\\quad \\gamma(s^t) \\ge \\beta (1 + r) \\sum_{s^{t + 1}} Pr(s^{t + 1}) \\gamma(s^{t + 1}) \\\\\n  &\\Leftrightarrow u'(c_i(s^t)) \\ge \\beta (1 + r) \\sum_{s^{t + 1}} Pr(s^{t + 1}) \\frac{u'(c_i(s^{t + 1}))}{1 - \\nu_i(s^{t + 1})},\n\\end{aligned}\n where equality holds when B(s^{t + 1}) > 0. These conditions determine the policy functions, and the individual value functions can be written with three state variables, (y, B, x), as follows: \n  V_i(y, B, x) = u_i(c_i(y, B, x)) + \\beta \\sum_{y'} Pr(y') V_i(y', B', x').\n\nThe interval update rule found in Ligon, Thomas, and Worrall (2002) holds in this context too, but interval bounds depend on public storage. Specifically, by defining the interval bounds, \\underline{x}(y, B) and \\overline{x}(y, B), V_2(y, B, \\underline{x}(y, B)) = U_2(y) and V_1(y, B, \\overline{x}(y, B)) = U_1(y), the relative Pareto weight x is updated such that the policy function x'(y, B, x) is characterized as follows: \nx'(y, B, x) = \\begin{cases}\n\\overline{x}(y, B) \\quad &\\text{if } x > \\overline{x}(y, B) \\\\\nx \\quad &\\text{if } x \\in [\\underline{x}(y, B), \\overline{x}(y, B)] \\\\\n\\underline{x}(y, B) \\quad &\\text{if } x < \\underline{x}(y, B).\n\\end{cases}\n\n\n\n1.1.2 Value of autarky with storage\nThe expected lifetime utility of an agent i under autarky with storage, at a state y with private savings b, is \n  V_i^{aut}(y, b) = \\max_{b' \\ge 0} \\left\\{ u(y_i + (1 + r) b - b') + \\beta \\sum_{y'} Pr(y') V_i^{aut} (y', b') \\right\\}.\n The intertemporal optimality condition, that is, the (individual) Euler equation, is \n  u'(c(y, b)) \\ge (1 + r) \\beta \\sum_j Pr(y') c(y', b'(y, b)),\n where the equality holds if \\beta'(y, b) \\ge 0. Note that b'(y, b) = y_i + (1 + r) b - c(y, b). I use the policy function iteration method to calculate c(y, b).\nWhat we are interested in is U_i^{aut} \\equiv V_i^{aut}(y, 0), that is, the autarky value when there is no private saving, since this is the state households consider in participation constraints."
  },
  {
    "objectID": "lc_storage_simulation.html",
    "href": "lc_storage_simulation.html",
    "title": "3  Risk sharing with limited commitment and storage: Simulation",
    "section": "",
    "text": "4 Load solution"
  },
  {
    "objectID": "lc_storage_simulation.html#code",
    "href": "lc_storage_simulation.html#code",
    "title": "3  Risk sharing with limited commitment and storage: Simulation",
    "section": "3.1 Code",
    "text": "3.1 Code\n\n3.1.1 Global settings\n\npacman::p_load(\n  tidyverse,\n  pracma,\n  latex2exp,\n  ggrepel\n)"
  },
  {
    "objectID": "lc_storage_simulation.html#transition-in-storage",
    "href": "lc_storage_simulation.html#transition-in-storage",
    "title": "3  Risk sharing with limited commitment and storage: Simulation",
    "section": "4.4 Transition in storage",
    "text": "4.4 Transition in storage\nHere, I show how storage evolves over time, depending on the sequence of income realizations. The figure uses different colors for different sequences (state 1: low HH1 income, state 2: medium HH1 income, state 3: high HH1 income).\n\nsimulationResult %>% \n  filter(period >= 100) %>% \n  mutate(cond = (income == 2)) %>% \n  ggplot() +\n  geom_point(aes(x = period, y = storage, color = changeIncome), size = 1.0) +\n  xlab('Time period') +\n  ylab('Public storage') +\n  theme_classic()\n\n\n\n\n\n4.4.1 No income inequality state\nWhen the income state 2 is realized, income is equal between two households, and the social planner stores nothing for the following period.\n\nsimulationResult %>% \n  filter(period >= 100) %>% \n  mutate(cond = (income == 2)) %>% \n  mutate(alpha = 1 * cond + 0.01 * (!cond)) %>% \n  ggplot() +\n  geom_point(aes(x = period, y = storage, color = changeIncome, alpha = alpha), size = 0.3) +\n  scale_alpha(guide = \"none\") +\n  xlab('Time period') +\n  ylab('Public storage') +\n  theme_classic()\n\n\n\n\n\n\n4.4.2 From no income inequality to some inequality\nWhen a medium income state is followed by an income state with inequality, the social planner makes savings.\n\nsimulationResult %>% \n  filter(period >= 100) %>% \n  mutate(cond = (income != 2 & previousIncome == 2)) %>% \n  mutate(alpha = 1 * cond + 0.2 * (!cond)) %>% \n  ggplot() +\n  geom_point(aes(x = period, y = storage, color = changeIncome, alpha = alpha), size = 0.3) +\n  scale_alpha(guide = \"none\") +\n  xlab('Time period') +\n  ylab('Public storage') +\n  theme_classic()\n\n\n\n\n\n\n4.4.3 Consecutvive states with some income inequality\nWhen unequal income states continue, more assets are accumulated.\n\nsimulationResult %>% \n  filter(period >= 100) %>% \n  mutate(cond = (income != 2 & previousIncome != 2)) %>% \n  mutate(alpha = 1 * cond + 0.2 * (!cond)) %>% \n  ggplot() +\n  geom_point(aes(x = period, y = storage, color = changeIncome, alpha = alpha), size = 0.3) +\n  scale_alpha(guide = \"none\") +\n  xlab('Time period') +\n  ylab('Public storage') +\n  theme_classic()\n\n\n\n\n\n\n\n\nKocherlakota, N. R. 1996. “Implications of Efficient Risk Sharing without Commitment.” The Review of Economic Studies 63 (4): 595–609. https://doi.org/10.2307/2297795."
  },
  {
    "objectID": "lc_no_storage.html#simulation-result",
    "href": "lc_no_storage.html#simulation-result",
    "title": "4  Comparison: Risk sharing with limited commitment but without storage",
    "section": "4.2 Simulation result",
    "text": "4.2 Simulation result\nThe figure shows the consumption evolution over time. Unlike the model with storage, the model without storage results in a consumption pattern which takes only a finite number of values in the steady state.\n\nsimulationResultNoStorage %>% \n  filter(period >= 100) %>% \n  ggplot() +\n  geom_point(aes(x = period, y = consHH1), size = 0.3) +\n  xlab('Time period') +\n  ylab('HH1 consumption') +\n  theme_classic()"
  }
]