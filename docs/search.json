[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Risk-sharing with limited commitment and storage",
    "section": "",
    "text": "Preface\nThis website explains a risk-sharing model with storage under limited commitment, based on Ábrahám and Laczó (2018). After reviewing the model, I show how to numerically solve it, and then I demonstrate a simulation result to deep-dive into the model implications. Finally, I compare the result with the case without storage (as in Ligon, Thomas, and Worrall (2002)) and show that the possibility of storage can worsen households’ welfare.\nFor writing R codes in this website, I refer to the Matlab scripts in the replication package of Ábrahám and Laczó (2018) provided in the journal website. Any errors are my own, and if you find any mistakes or wrong statements, feel free to report it to me, through the GitHub’s issue page or via email.\nContact: Mizuhiro Suzuki (mizuhiro.suzuki@gmail.com)\nGitHub repo: https://github.com/mizuhirosuzuki/risk_sharing_lc_storage"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "lc_storage_model.html#value-of-autarky-with-storage",
    "href": "lc_storage_model.html#value-of-autarky-with-storage",
    "title": "1  Risk sharing with limited commitment and storage: Model",
    "section": "1.1 Value of autarky with storage",
    "text": "1.1 Value of autarky with storage\nThe expected lifetime utility of an agent i under autarky with storage, at a state s with private savings b, is \n  V_i^{aut}(s, b) = \\max_{b' \\ge 0} \\left\\{ u(y_i^s + (1 + r) b - b') + \\beta \\sum_{j} \\pi^j V_i^{aut} (y^j, b') \\right\\}.\n The intertemporal optimality condition, that is, the (individual) Euler equation, is \n  u'(c(s, b)) \\ge (1 + r) \\beta \\sum_j \\pi^j c(j, b'(s, b)),\n where the equality holds if \\beta'(s, b) \\ge 0. Note that b'(s, b) = y_i^s + (1 + r) b - c(s, b). I use the policy function iteration method to calculate c(s, b).\nWhat we are interested in is U_i^{aut} \\equiv V_i^{aut}(s, 0), that is, the autarky value when there is no private saving, since this is the state households consider in participation constraints."
  },
  {
    "objectID": "lc_storage_solution.html#steps-for-solving-the-model",
    "href": "lc_storage_solution.html#steps-for-solving-the-model",
    "title": "2  Risk sharing with limited commitment and storage: Numerical solution",
    "section": "2.1 Steps for solving the model",
    "text": "2.1 Steps for solving the model\nBased on the modeling solution described above, I explain how to solve the model numerically. Prepare V_1^0(y, B, x), V_2^0(y, B, x), \\underline{x}^0(y, B), \\overline{x}^0(y, B), and B'^0(y, B, x), and below I describe the steps in h’th iteration. Note that the updating rule of relative Pareto weight, x'^h(y, B, x) is determined by (\\underline{x}^h(y, B), \\overline{x}^h(y, B)).\n\nFirst, I update \\overline{x}(y, B). For this, solve for \\overline{x}(y, B) in the equation below such that the household 1’s participation constraint binds with 0 next-period saving: \n  u(c_1(y, B, \\overline{x}(y, B))) + \\beta \\sum_{y'} Pr(y') V_1^{h - 1}(y', 0, \\overline{x}(y, B)) = U_1^{aut}(y),\n where \n  c_1(y, B, \\overline{x}(y, B)) = \\frac{y + (1 + r)B}{1 + \\overline{x}(y, B)}.\n Then check if the planner’s Euler equation is satisfied at this \\overline{x}(y, B), by seeing if the following expression is non-negative or not: \n  u'(c_1(y, B, \\overline{x}(y, B))) - \\beta (1 + r) \\sum_{y'} Pr(y') \\frac{u'(c_1(y', 0, \\overline{x}(y, B)))}{1 - \\nu_1(y', 0, \\overline{x}(y, B))},\n where, \n\\begin{aligned}\n  c_1(y', 0, \\overline{x}(y, B)) &= \\frac{y' - B'^{(h - 1)}(y', 0, \\overline{x}(y, B))}{1 + x'^{(h - 1)}(y', 0, \\overline{x}(y, B))} \\\\\n  \\nu_1(y', 0, \\overline{x}(y, B)) &= \\min \\left\\{ 1 - \\frac{x'^{(h - 1)}(y', 0, \\overline{x}(y, B))}{\\overline{x}(y, B)}, 1 \\right\\}.\n\\end{aligned}\n If this is non-negative, update B'^h(y, B, \\overline{x}(y, B)) = 0 and \\overline{x}^h(y, B) = \\overline{x}(y, B). If this is negative, then since the planner’s Euler equation is violated with B' = 0, I solve the following non-linear system of two equations for \\overline{x}(y, B) and B': \n\\begin{aligned}\n  &u'(c_1(y, B, \\overline{x}(y, B))) - \\beta (1 + r) \\sum_{y'} Pr(y') \\frac{u'(c_1(y', B', \\overline{x}(y, B)))}{1 - \\nu_1(y', B', \\overline{x}(y, B))} = 0 \\\\\n  &u(c_1(y, B, \\overline{x}(y, B))) + \\beta \\sum_{y'} Pr(y') V_1^{h - 1}(y', B', \\overline{x}(y, B)) = U_1^{aut}(y),\n\\end{aligned}\n and update B'^h(y, B, \\overline{x}(y, B)) and \\overline{x}^h(y, B) with the solutions. The value functions are updated such that \n\\begin{aligned}\n  V_1^{h}(y, B, \\overline{x}(y, B)) &= U_1^{aut}(y) \\\\\n  V_2^{h}(y, B, \\overline{x}(y, B)) &= u(c_2(y, B, \\overline{x}(y, B))) + \\beta \\sum_{y'} Pr(y') V_2^{h - 1}(y', B'^h(y, B, \\overline{x}(y, B)), \\overline{x}(y, B)).\n\\end{aligned}\n\nNext, I update \\underline{x}(y, B) in a similar way. First solve for \\underline{x}(y, B) such that the household 2’s participation constraint binds with 0 next-period saving: \n  u(c_2(y, B, \\underline{x}(y, B))) + \\beta \\sum_{y'} Pr(y') V_2^{h - 1}(y', 0, \\underline{x}(y, B)) = U_2^{aut}(y),\n where \n  c_2(y, B, \\underline{x}(y, B)) = \\frac{y + (1 + r)B}{1 + 1 / \\underline{x}(y, B)}.\n And I check if the planner’s Euler equation is satisfied at \\overline{x}(y, B) with B' = 0, by checking if \n  u'(c_1(y, B, \\underline{x}(y, B))) - \\beta (1 + r) \\sum_{y'} Pr(y') \\frac{u'(c_1(y', 0, \\underline{x}(y, B)))}{1 - \\nu_1(y', 0, \\underline{x}(y, B))} \\ge 0\n or not. If this is the case, update B'^h(y, B, \\underline{x}(y, B)) = 0 and \\underline{x}^h(y, B) = \\underline{x}(y, B). Otherwise, since the planner’s Euler equation is violated with B' = 0, I solve the following non-linear system of two equations for B' and \\underline{x}(y, B): \n\\begin{aligned}\n  &u'(c_1(y, B, \\underline{x}(y, B))) - \\beta (1 + r) \\sum_{y'} Pr(y') \\frac{u'(c_1(y', B', \\underline{x}(y, B)))}{1 - \\nu_1(y', B', \\underline{x}(y, B))} = 0 \\\\\n  &u(c_2(y, B, \\underline{x}(y, B))) + \\beta \\sum_{y'} Pr(y') V_2^{h - 1}(y', B', \\underline{x}(y, B)) = U_2^{aut}(y),\n\\end{aligned}\n and update B'^h(y, B, \\underline{x}(y, B)) and \\underline{x}^h(y, B) with the solutions. The value functions are updated such that \n\\begin{aligned}\n  V_1^{h}(y, B, \\underline{x}(y, B)) &= u(c_1(y, B, \\underline{x}(y, B))) + \\beta \\sum_{y'} Pr(y') V_1^{h - 1}(y', B'^h(y, B, \\underline{x}(y, B)), \\underline{x}(y, B)) \\\\\n  V_2^{h}(y, B, \\underline{x}(y, B)) &= U_2^{aut}(y).\n\\end{aligned}\n\nFor x \\in [\\underline{x}(y, B), \\overline{x}(y, B)], where no participation constraint binds, first check if B' = 0 satisfied the planner’s Euler equation: \n  u'(c_1(y, B, x)) \\ge \\beta (1 + r) \\sum_{y'} Pr(y') \\frac{u'(c_1(y', 0, x))}{1 - \\nu_1(y', 0, x)}.\n If this is violated, I solve for B' such that the planner’s Euler equation holds with equality: \n  u'(c_1(y, B, x)) = \\beta (1 + r) \\sum_{y'} Pr(y') \\frac{u'(c_1(y', B', x))}{1 - \\nu_1(y', B', x)}.\n Then update B'^h(y, B, x) with the solution. The value functions are updated as follows: \n\\begin{aligned}\n  V_1^{h}(y, B, x) &= u(c_1(y, B, x)) + \\beta \\sum_{y'} Pr(y') V_1^{h - 1}(y', B'^h(y, B, x), x) \\\\\n  V_2^{h}(y, B, x) &= u(c_1(y, B, x)) + \\beta \\sum_{y'} Pr(y') V_1^{h - 1}(y', B'^h(y, B, x), x).\n\\end{aligned}\n\nFor x < \\underline{y, B}, update the policy functions and value functions in the following way (remember that these do not depend on x, as discussed in the modeling solution section above): \n\\begin{aligned}\n  V_1^{h}(y, B, x) &= V_1^h(y, B, \\underline{x}(y, B)) \\\\\n  V_2^{h}(y, B, x) &= U_2^{aut}(y) \\\\\n  B^h(y, B, x) &= B^h(y, B, \\underline{x}(y, B)).\n\\end{aligned}\n Similarly, for x > \\overline{y, B}, the policy functions and value functions are updated such that \n\\begin{aligned}\n  V_1^{h}(y, B, x) &= U_1^{aut}(y) \\\\\n  V_2^{h}(y, B, x) &= V_2^h(y, B, \\overline{x}(y, B)) \\\\\n  B^h(y, B, x) &= B^h(y, B, \\overline{x}(y, B)).\n\\end{aligned}"
  },
  {
    "objectID": "lc_storage_solution.html#numerical-solutions",
    "href": "lc_storage_solution.html#numerical-solutions",
    "title": "2  Risk sharing with limited commitment and storage: Numerical solution",
    "section": "2.2 Numerical solutions",
    "text": "2.2 Numerical solutions\n\n2.2.1 Global settings\n\npacman::p_load(\n  tidyverse,\n  nleqslv,\n  pracma,\n  tictoc\n)\n\n\nset.seed(123)\n\nnumStates <- 3\nnumRelativeParetoWeights <- 201\nbeta <- 0.8\nsigma <- 1\n\nincomeGridPointsHH1 <- c(0.353, 0.5, 0.647)\nincomeGridPointsHH2 <- 1 - incomeGridPointsHH1\naggregateIncome <- 1\naggregateIncomeGridPoints <- incomeGridPointsHH1 + incomeGridPointsHH2\n\nincomeTransitionProbVec <- rep(1 / 3, 3)\nincomeTransitionMatrix <- matrix(1 / 3, nrow = 3, ncol = 3)\n\nreturnOnStorage <- 0.02\n\n\ncalculateUtility <- function(cons, sigma) {\n  if (sigma != 1) {\n    utility = (cons^(1 - sigma) - 1) / (1 - sigma)\n  } else if (sigma == 1) {\n    utility = log(cons)\n  }\n  return(utility)\n}\ncalculateMarginalUtility <- function(cons, sigma) cons^(- sigma)\n\n\nstorageGridPoints <- seq(0, sqrt(max(incomeGridPointsHH1)), by = 1e-2)^2\nnumStorageGridPoints <- length(storageGridPoints)\n\n\nmaxRelativeParetoWeight <- (\n  (1 + (1 + returnOnStorage) * max(storageGridPoints)) / min(incomeGridPointsHH1) - 1\n)\nminRelativeParetoWeight <- 1 / maxRelativeParetoWeight\n\nrelativeParetoWeightsGridPoints <- c(\n  seq(\n    minRelativeParetoWeight, 1,\n    by = (1 - minRelativeParetoWeight) / floor(numRelativeParetoWeights / 2)\n  ),\n  rev(1 / seq(\n    minRelativeParetoWeight, 1,\n    by = (1 - minRelativeParetoWeight) / floor(numRelativeParetoWeights / 2)\n  )[1:floor(numRelativeParetoWeights / 2)])\n)\n\n\n\n2.2.2 Value at autarky with private storage\n\ncalculateEulerEquationDiffAutarky <- function(\n    consumption,\n    income,\n    storage,\n    beta,\n    sigma,\n    returnOnStorage,\n    incomeProb,\n    storageGridPoints,\n    consumptionAutarkyMatrix\n) {\n  \n  interpolatedConsumptionByIncome <- apply(\n    consumptionAutarkyMatrix,\n    1,\n    function(x) {\n      approx(\n        storageGridPoints,\n        x,\n        income + (1 + returnOnStorage) * storage - consumption,\n        rule = 2\n      )$y}\n  )\n  \n  return(\n    calculateMarginalUtility(consumption, sigma) - (\n      beta * (1 + returnOnStorage) * (\n        incomeProb %*% calculateMarginalUtility(interpolatedConsumptionByIncome, sigma)\n      )\n    )\n  )\n}\n\ninterpolateValueByIncome <- function(\n    consumption,\n    income,\n    storage,\n    valueAutarkyMatrix,\n    storageGridPoints,\n    returnOnStorage\n) {\n  return(\n    apply(\n      valueAutarkyMatrix,\n      1,\n      function(x) {\n        approx(\n          storageGridPoints,\n          x,\n          income + (1 + returnOnStorage) * storage - consumption,\n          rule = 2\n          )$y}\n      )     \n    )\n}\n\nupdateValueAutarky <- function(\n  consumption,\n  interpolatedValueByIncome,\n  incomeProb,\n  beta,\n  sigma\n) {\n  return(\n    (\n      calculateUtility(consumption, sigma)\n      + beta * (\n        incomeProb %*% interpolatedValueByIncome\n      )\n    )\n  )\n}\n\ncomputeConsumptionAutarky <- function(\n    returnOnStorage,\n    storageGridPoints,\n    incomeGridPoints,\n    beta,\n    sigma,\n    incomeProb,\n    numStates,\n    numStorageGridPoints,\n    iterationTol = 1e-8,\n    maxIteration = 100\n) {\n  \n  consumptionAutarkyMatrix <- outer(rep(1, numStates), (1 / beta - 1) * storageGridPoints) + 1e-8\n  consumptionAutarkyMatrixNew <- matrix(NA, nrow = numStates, numStorageGridPoints)\n\n  iter <- 1\n  diff <- 1\n  while ((diff > iterationTol) & (iter < maxIteration)) {\n    \n    for (stateIndex in seq(1, numStates)) {\n      for (storageIndex in seq(1, numStorageGridPoints)) {\n        \n        if (calculateEulerEquationDiffAutarky(\n            storageGridPoints[storageIndex] * (1 + returnOnStorage) + incomeGridPoints[stateIndex],\n            incomeGridPoints[stateIndex],\n            storageGridPoints[storageIndex],\n            beta,\n            sigma,\n            returnOnStorage,\n            incomeTransitionMatrix[stateIndex,],\n            storageGridPoints,\n            consumptionAutarkyMatrix\n        ) >= 0) {\n          consumptionAutarkyMatrixNew[stateIndex, storageIndex] <- (\n            storageGridPoints[storageIndex] * (1 + returnOnStorage) + incomeGridPoints[stateIndex]\n          )\n        } else {\n          consumptionAutarkyMatrixNew[stateIndex, storageIndex] <- uniroot(\n          function(x) {calculateEulerEquationDiffAutarky(\n            x,\n            incomeGridPoints[stateIndex],\n            storageGridPoints[storageIndex],\n            beta,\n            sigma,\n            returnOnStorage,\n            incomeTransitionMatrix[stateIndex, ],\n            storageGridPoints,\n            consumptionAutarkyMatrix\n            )},\n            c(\n              1e-12, \n              storageGridPoints[storageIndex] * (1 + returnOnStorage) + incomeGridPoints[stateIndex]\n              )\n          )$root\n        }\n      }\n    }\n    \n    diff <- max(abs(consumptionAutarkyMatrixNew - consumptionAutarkyMatrix))\n    consumptionAutarkyMatrix <- consumptionAutarkyMatrixNew\n    iter <- iter + 1\n  }\n  \n  return(consumptionAutarkyMatrix)\n}\n\ncomputeValueAutarky <- function(\n    consumptionAutarkyMatrix,\n    returnOnStorage,\n    storageGridPoints,\n    incomeGridPoints,\n    beta,\n    sigma,\n    incomeProb,\n    numStates,\n    numStorageGridPoints,\n    iterationTol = 1e-8,\n    maxIteration = 100\n) {\n  \n  valueAutarkyMatrix <- calculateUtility(consumptionAutarkyMatrix, sigma) / (1 - beta)\n  valueAutarkyMatrixNew <- matrix(NA, nrow = numStates, ncol = numStorageGridPoints)\n  \n  iter <- 1\n  diff <- 1\n  while ((diff > iterationTol) & (iter < maxIteration)) {\n    \n    for (stateIndex in seq(1, numStates)) {\n      for (storageIndex in seq(1, numStorageGridPoints)) {\n        \n        interpolatedValueByIncome <- interpolateValueByIncome(\n          consumptionAutarkyMatrix[stateIndex, storageIndex],\n          incomeGridPoints[stateIndex],\n          storageGridPoints[storageIndex],\n          valueAutarkyMatrix,\n          storageGridPoints,\n          returnOnStorage\n        )\n        valueAutarkyMatrixNew[stateIndex, storageIndex] <- updateValueAutarky(\n          consumptionAutarkyMatrix[stateIndex, storageIndex],\n          interpolatedValueByIncome,\n          incomeTransitionMatrix[stateIndex,],\n          beta,\n          sigma\n        ) %>% as.numeric\n      }\n    }\n    \n    diff <- max(abs(valueAutarkyMatrixNew - valueAutarkyMatrix))\n    valueAutarkyMatrix <- valueAutarkyMatrixNew\n    iter <- iter + 1\n    \n  }\n  \n  return(valueAutarkyMatrix)\n}\n\nsolveValueAutarky <- function(\n    returnOnStorage,\n    storageGridPoints,\n    incomeGridPoints,\n    beta,\n    sigma,\n    incomeProb,\n    numStates,\n    numStorageGridPoints\n) {\n  \n  consumptionAutarkyMatrix <- computeConsumptionAutarky(\n      returnOnStorage,\n      storageGridPoints,\n      incomeGridPoints,\n      beta,\n      sigma,\n      incomeProb,\n      numStates,\n      numStorageGridPoints\n  )\n  \n  valueAutarkyMatrix <- computeValueAutarky(\n      consumptionAutarkyMatrix,\n      returnOnStorage,\n      storageGridPoints,\n      incomeGridPoints,\n      beta,\n      sigma,\n      incomeProb,\n      numStates,\n      numStorageGridPoints\n  )\n  \n  valueAutarkyZeroPrivateSaving <- valueAutarkyMatrix[, 1]\n  \n  return(valueAutarkyZeroPrivateSaving)\n\n}\n\n\nvalueAutarkyHH1 <- solveValueAutarky(\n    returnOnStorage,\n    storageGridPoints,\n    incomeGridPointsHH1,\n    beta,\n    sigma,\n    incomeProb,\n    numStates,\n    numStorageGridPoints\n)\n\nvalueAutarkyHH2 <- solveValueAutarky(\n    returnOnStorage,\n    storageGridPoints,\n    incomeGridPointsHH2,\n    beta,\n    sigma,\n    incomeProb,\n    numStates,\n    numStorageGridPoints\n)\n\n\ncalculateHH1Consumption <- function(\n  aggregateResources,\n  relativeParetoWeight,\n  sigma\n) {\n    aggregateResources / (1 + (relativeParetoWeight^(1 / sigma)))\n}\n\ncalculateHH2Consumption <- function(\n  aggregateResources,\n  relativeParetoWeight,\n  sigma\n) {\n  (\n    aggregateResources \n    - aggregateResources / (1 + (relativeParetoWeight^(1 / sigma)))\n  )\n}\n\n\ncalculateEulerEquationDiff <- function(\n    aggregateIncome,\n    currentStorage,\n    currentRelativeParetoWeight,\n    returnOnStorage,\n    nextPeriodStorage,\n    aggregateIncomeGridPoints,\n    relativeParetoWeightsGridPoints,\n    nextStorageArray,\n    relativeParetoWeightsBoundsArray,\n    incomeTransitionProbVec,\n    numStates,\n    sigma,\n    beta\n) {\n  \n  nextRelativeParetoWeight <- map_dbl(\n    seq(1, numStates),\n    function(x) {\n      currentRelativeParetoWeight %>% \n        pmax(\n          approx(\n            storageGridPoints,\n            relativeParetoWeightsBoundsArray[1, x, ],\n            nextPeriodStorage,\n            rule = 2\n          )$y\n        ) %>% \n        pmin(\n          approx(\n            storageGridPoints,\n            relativeParetoWeightsBoundsArray[2, x, ],\n            nextPeriodStorage,\n            rule = 2\n          )$y\n        )\n    }\n  )\n  \n  nu <- (1 - (nextRelativeParetoWeight / currentRelativeParetoWeight)) %>% pmax(0)\n  \n  return(\n    calculateMarginalUtility(\n      calculateHH1Consumption(\n          aggregateIncome\n          + (1 + returnOnStorage) * currentStorage - nextPeriodStorage,\n          currentRelativeParetoWeight,\n          sigma\n        ),\n      sigma\n    ) - (\n      beta * (1 + returnOnStorage) * incomeTransitionProbVec %*% (\n        calculateMarginalUtility(\n          calculateHH1Consumption(\n            aggregateIncomeGridPoints \n            + (1 + returnOnStorage) * nextPeriodStorage \n            - map_dbl(\n              seq(1, numStates),\n              function(xx) interp2(\n                x = storageGridPoints,\n                y = relativeParetoWeightsGridPoints,\n                Z = nextStorageArray[xx, , ],\n                xp = nextPeriodStorage %>% \n                  pmin(max(storageGridPoints)) %>% \n                  pmax(min(storageGridPoints)),\n                yp = nextRelativeParetoWeight[xx] %>%\n                  pmin(max(relativeParetoWeightsGridPoints)) %>%\n                  pmax(min(relativeParetoWeightsGridPoints)),\n                method = \"linear\"\n                )\n              ),\n            nextRelativeParetoWeight,\n            sigma\n          ),\n          sigma\n        ) / (1 - nu)\n      ) %>% as.numeric \n    )\n  )\n}\n\ncalculateValue <- function(\n    aggregateIncome,\n    currentStorage,\n    currentRelativeParetoWeight,\n    returnOnStorage,\n    nextPeriodStorage,\n    relativeParetoWeightsGridPoints,\n    valueArray,\n    incomeTransitionProbVec,\n    numStates,\n    sigma,\n    beta,\n    calculateHouseholdConsumption\n) {\n \n  return(\n    calculateUtility(\n      calculateHouseholdConsumption(\n        aggregateIncome\n          + (1 + returnOnStorage) * currentStorage\n          - nextPeriodStorage,\n        currentRelativeParetoWeight,\n        sigma\n      ) %>% pmax(1e-12)\n      , sigma\n    ) + (\n      beta \n      * incomeTransitionProbVec \n      %*% map_dbl(\n        seq(1, numStates),\n        function(xx) {interp2(\n            x = storageGridPoints,\n            y = relativeParetoWeightsGridPoints,\n            Z = valueArray[xx, , ],\n            xp = nextPeriodStorage %>% \n              pmin(max(storageGridPoints)) %>% \n              pmax(min(storageGridPoints)),\n            yp = currentRelativeParetoWeight %>% \n              pmin(max(relativeParetoWeightsGridPoints)) %>% \n              pmax(min(relativeParetoWeightsGridPoints)),\n            method = \"linear\"\n        )}\n        ) %>% as.numeric)\n  )\n}\n\ncalculatePCDiff <- function(\n    aggregateIncome,\n    currentStorage,\n    currentRelativeParetoWeight,\n    returnOnStorage,\n    nextPeriodStorage,\n    relativeParetoWeightsGridPoints,\n    valueArray,\n    valueAutarky,\n    incomeTransitionProbVec,\n    numStates,\n    sigma,\n    beta,\n    calculateHouseholdConsumption\n) {\n    return(\n      calculateValue(\n        aggregateIncome,\n        currentStorage,\n        currentRelativeParetoWeight,\n        returnOnStorage,\n        nextPeriodStorage,\n        relativeParetoWeightsGridPoints,\n        valueArray,\n        incomeTransitionProbVec,\n        numStates,\n        sigma,\n        beta,\n        calculateHouseholdConsumption\n        ) - valueAutarky\n    )\n}\n\n\nconsumptionOnRelativeParetoWeightAndStorageGridHH1 <- array(\n  NA, dim = c(numStates, numRelativeParetoWeights, numStorageGridPoints)\n  )\nfor (stateIndex in seq(1, numStates)) {\n  for (weightIndex in seq(1, numRelativeParetoWeights)) {\n    consumptionOnRelativeParetoWeightAndStorageGridHH1[stateIndex, weightIndex, ] <- (\n        calculateHH1Consumption(\n          aggregateIncomeGridPoints[stateIndex] + (1 + returnOnStorage) * storageGridPoints,\n          relativeParetoWeightsGridPoints[weightIndex],\n          sigma\n          )\n      )\n    }\n  }\nconsumptionOnRelativeParetoWeightAndStorageGridHH2 <- array(\n  NA, dim = c(numStates, numRelativeParetoWeights, numStorageGridPoints)\n  )\nfor (stateIndex in seq(1, numStates)) {\n  for (weightIndex in seq(1, numRelativeParetoWeights)) {\n    consumptionOnRelativeParetoWeightAndStorageGridHH2[stateIndex, weightIndex, ] <- (\n        aggregateIncomeGridPoints[stateIndex] + (1 + returnOnStorage) * storageGridPoints \n        - consumptionOnRelativeParetoWeightAndStorageGridHH1[stateIndex, weightIndex, ]\n      )\n  }\n}\n\nvalueArrayHH1 <- (\n  calculateUtility(consumptionOnRelativeParetoWeightAndStorageGridHH1, sigma) / (1 - beta)\n)\nvalueArrayHH2 <- (\n  calculateUtility(consumptionOnRelativeParetoWeightAndStorageGridHH2, sigma) / (1 - beta)\n)\nvalueArrayHH1New <- valueArrayHH1\nvalueArrayHH2New <- valueArrayHH2\n\n\nrelativeParetoWeightsBoundsArray <- array(\n  1, dim = c(2, numStates, numStorageGridPoints)\n)\nrelativeParetoWeightsBoundsArrayNew <- array(\n  NA, dim = c(2, numStates, numStorageGridPoints)\n)\n\nnextStorageArray <- array(\n  0, dim = c(numStates, numRelativeParetoWeights, numStorageGridPoints)\n  )\nnextStorageArrayNew <- array(\n  0, dim = c(numStates, numRelativeParetoWeights, numStorageGridPoints)\n  )\n\n\ndiff <- 1\niter <- 1\nwhile ((diff > 1e-4) & (iter < 120)) {\n  \n  for (stateIndex in seq(1, numStates)) {\n    print(stateIndex)\n    tic()\n    for (storageIndex in seq(1, numStorageGridPoints)) {\n      \n      # (i) Find upper bound\n      if (\n        calculatePCDiff(\n              aggregateIncome,\n              currentStorage = storageGridPoints[storageIndex],\n              currentRelativeParetoWeight = max(relativeParetoWeightsGridPoints),\n              returnOnStorage,\n              nextPeriodStorage = 0,\n              relativeParetoWeightsGridPoints,\n              valueArray = valueArrayHH1,\n              valueAutarky = valueAutarkyHH1[stateIndex],\n              incomeTransitionProbVec,\n              numStates,\n              sigma,\n              beta,\n              calculateHH1Consumption\n            ) > 0\n      ) {\n        relativeParetoWeightsUpperTmp <- max(relativeParetoWeightsGridPoints)\n      } else {\n        relativeParetoWeightsUpperTmp <- uniroot(\n          function(x) {\n            calculatePCDiff(\n              aggregateIncome,\n              currentStorage = storageGridPoints[storageIndex],\n              currentRelativeParetoWeight = x,\n              returnOnStorage,\n              nextPeriodStorage = 0,\n              relativeParetoWeightsGridPoints,\n              valueArray = valueArrayHH1,\n              valueAutarky = valueAutarkyHH1[stateIndex],\n              incomeTransitionProbVec,\n              numStates,\n              sigma,\n              beta,\n              calculateHH1Consumption\n            )\n          },\n          c(min(relativeParetoWeightsGridPoints), max(relativeParetoWeightsGridPoints))\n        )$root\n      }\n      \n      if (\n        calculateEulerEquationDiff(\n          aggregateIncomeGridPoints[stateIndex],\n          storageGridPoints[storageIndex],\n          currentRelativeParetoWeight = relativeParetoWeightsUpperTmp,\n          returnOnStorage,\n          nextPeriodStorage = 0,\n          aggregateIncomeGridPoints,\n          relativeParetoWeightsGridPoints,\n          nextStorageArray,\n          relativeParetoWeightsBoundsArray,\n          incomeTransitionProbVec,\n          numStates,\n          sigma,\n          beta\n          ) >= 0\n      ) {\n        nextStorageArrayNew[\n          stateIndex, \n          which.min(abs(\n            relativeParetoWeightsUpperTmp - relativeParetoWeightsGridPoints\n            )), \n          storageIndex\n          ] <- 0\n        relativeParetoWeightsBoundsArrayNew[2, stateIndex, storageIndex] <- relativeParetoWeightsUpperTmp\n      } else {\n        resSolve <- nleqslv(\n          c(0.5, 1),\n          function(x) {\n            nextPeriodStorage <- x[1]\n            relativeParetoWeightUpperBound <- x[2]\n            y <- numeric(2)\n            \n            y[1] <- calculateEulerEquationDiff(\n              aggregateIncomeGridPoints[stateIndex],\n              storageGridPoints[storageIndex],\n              currentRelativeParetoWeight = relativeParetoWeightUpperBound,\n              returnOnStorage,\n              nextPeriodStorage = nextPeriodStorage,\n              aggregateIncomeGridPoints,\n              relativeParetoWeightsGridPoints,\n              nextStorageArray,\n              relativeParetoWeightsBoundsArray,\n              incomeTransitionProbVec,\n              numStates,\n              sigma,\n              beta\n              )\n            \n            y[2] <- calculatePCDiff(\n              aggregateIncomeGridPoints[stateIndex],\n              storageGridPoints[storageIndex],\n              currentRelativeParetoWeight = relativeParetoWeightUpperBound,\n              returnOnStorage,\n              nextPeriodStorage = nextPeriodStorage,\n              relativeParetoWeightsGridPoints,\n              valueArray = valueArrayHH1,\n              valueAutarky = valueAutarkyHH1[stateIndex],\n              incomeTransitionProbVec,\n              numStates,\n              sigma,\n              beta,\n              calculateHH1Consumption\n              )\n            return(y)\n          }\n        )$x\n        nextStorageArrayNew[\n          stateIndex, \n          which.min(abs(\n            resSolve[2] - relativeParetoWeightsGridPoints\n            )), \n          storageIndex\n          ] <- resSolve[1]\n        relativeParetoWeightsBoundsArrayNew[2, stateIndex, storageIndex] <- resSolve[2]\n      }\n      \n      # (ii) Find lower bound\n      if (\n        calculatePCDiff(\n          aggregateIncomeGridPoints[stateIndex],\n          currentStorage = storageGridPoints[storageIndex],\n          currentRelativeParetoWeight = min(relativeParetoWeightsGridPoints),\n          returnOnStorage,\n          nextPeriodStorage = 0,\n          relativeParetoWeightsGridPoints,\n          valueArray = valueArrayHH2,\n          valueAutarky = valueAutarkyHH2[stateIndex],\n          incomeTransitionProbVec,\n          numStates,\n          sigma,\n          beta,\n          calculateHH2Consumption\n        ) > 0\n      ) {\n        relativeParetoWeightsLowerTmp <- min(relativeParetoWeightsGridPoints)\n      } else {\n        relativeParetoWeightsLowerTmp <- uniroot(\n          function(x) {\n            calculatePCDiff(\n              aggregateIncomeGridPoints[stateIndex],\n              currentStorage = storageGridPoints[storageIndex],\n              currentRelativeParetoWeight = x,\n              returnOnStorage,\n              nextPeriodStorage = 0,\n              relativeParetoWeightsGridPoints,\n              valueArray = valueArrayHH2,\n              valueAutarky = valueAutarkyHH2[stateIndex],\n              incomeTransitionProbVec,\n              numStates,\n              sigma,\n              beta,\n              calculateHH2Consumption\n            )\n          },\n          c(min(relativeParetoWeightsGridPoints), max(relativeParetoWeightsGridPoints))\n        )$root\n      }\n      \n      if (\n        calculateEulerEquationDiff(\n          aggregateIncomeGridPoints[stateIndex],\n          storageGridPoints[storageIndex],\n          currentRelativeParetoWeight = relativeParetoWeightsLowerTmp,\n          returnOnStorage,\n          nextPeriodStorage = 0,\n          aggregateIncomeGridPoints,\n          relativeParetoWeightsGridPoints,\n          nextStorageArray,\n          relativeParetoWeightsBoundsArray,\n          incomeTransitionProbVec,\n          numStates,\n          sigma,\n          beta\n          ) >= 0\n      ) {\n        nextStorageArrayNew[\n          stateIndex, \n          which.min(abs(\n            relativeParetoWeightsLowerTmp - relativeParetoWeightsGridPoints\n            )), \n          storageIndex\n          ] <- 0\n        relativeParetoWeightsBoundsArrayNew[1, stateIndex, storageIndex] <- relativeParetoWeightsLowerTmp\n      } else {\n        resSolve <- nleqslv(\n          c(0.5, 1),\n          function(x) {\n            nextPeriodStorage <- x[1]\n            relativeParetoWeightLowerBound <- x[2]\n            y <- numeric(2)\n            \n            y[1] <- calculateEulerEquationDiff(\n              aggregateIncomeGridPoints[stateIndex],\n              storageGridPoints[storageIndex],\n              currentRelativeParetoWeight = relativeParetoWeightLowerBound,\n              returnOnStorage,\n              nextPeriodStorage = nextPeriodStorage,\n              aggregateIncomeGridPoints,\n              relativeParetoWeightsGridPoints,\n              nextStorageArray,\n              relativeParetoWeightsBoundsArray,\n              incomeTransitionProbVec,\n              numStates,\n              sigma,\n              beta\n              )\n            \n            y[2] <- calculatePCDiff(\n              aggregateIncomeGridPoints[stateIndex],\n              storageGridPoints[storageIndex],\n              currentRelativeParetoWeight = relativeParetoWeightLowerBound,\n              returnOnStorage,\n              nextPeriodStorage = nextPeriodStorage,\n              relativeParetoWeightsGridPoints,\n              valueArray = valueArrayHH2,\n              valueAutarky = valueAutarkyHH2[stateIndex],\n              incomeTransitionProbVec,\n              numStates,\n              sigma,\n              beta,\n              calculateHH2Consumption\n              )\n            \n            return(y)\n          }\n        )$x\n        nextStorageArrayNew[\n          stateIndex, \n          which.min(abs(\n            resSolve[2] - relativeParetoWeightsGridPoints\n            )), \n          storageIndex\n          ] <- resSolve[1]\n        relativeParetoWeightsBoundsArrayNew[1, stateIndex, storageIndex] <- resSolve[2]\n      }\n      \n      # (iii) Calculate values in between\n      relativeParetoWeightsLower <- relativeParetoWeightsBoundsArrayNew[1, stateIndex, storageIndex]\n      relativeParetoWeightsUpper <- relativeParetoWeightsBoundsArrayNew[2, stateIndex, storageIndex]\n      \n      relativeParetoWeightsLowerIndex <- which.min(\n        abs(relativeParetoWeightsGridPoints - relativeParetoWeightsLower)\n        )\n      relativeParetoWeightsUpperIndex <- which.min(\n        abs(relativeParetoWeightsGridPoints - relativeParetoWeightsUpper)\n        )\n      \n      for (weightIndex in seq(relativeParetoWeightsLowerIndex, relativeParetoWeightsUpperIndex)) {\n        \n        if (\n         calculateEulerEquationDiff(\n            aggregateIncomeGridPoints[stateIndex],\n            storageGridPoints[storageIndex],\n            relativeParetoWeightsGridPoints[weightIndex],\n            returnOnStorage,\n            nextPeriodStorage = 0,\n            aggregateIncomeGridPoints,\n            relativeParetoWeightsGridPoints,\n            nextStorageArray,\n            relativeParetoWeightsBoundsArray,\n            incomeTransitionMatrix[stateIndex,],\n            numStates,\n            sigma,\n            beta\n        ) > 0) {\n          nextStorageArrayNew[stateIndex, weightIndex, storageIndex] <- 0\n          valueArrayHH1New[stateIndex, weightIndex, storageIndex] <- calculateValue(\n            aggregateIncomeGridPoints[stateIndex],\n            storageGridPoints[storageIndex],\n            currentRelativeParetoWeight = relativeParetoWeightsGridPoints[weightIndex],\n            returnOnStorage,\n            nextPeriodStorage = 0,\n            relativeParetoWeightsGridPoints,\n            valueArrayHH1,\n            incomeTransitionProbVec,\n            numStates,\n            sigma,\n            beta,\n            calculateHH1Consumption\n            )\n          valueArrayHH2New[stateIndex, weightIndex, storageIndex] <- calculateValue(\n            aggregateIncomeGridPoints[stateIndex],\n            storageGridPoints[storageIndex],\n            currentRelativeParetoWeight = relativeParetoWeightsGridPoints[weightIndex],\n            returnOnStorage,\n            nextPeriodStorage = 0,\n            relativeParetoWeightsGridPoints,\n            valueArrayHH2,\n            incomeTransitionProbVec,\n            numStates,\n            sigma,\n            beta,\n            calculateHH2Consumption\n            )\n        } else {\n          nextStorageArrayNew[stateIndex, weightIndex, storageIndex] <- uniroot(\n            function(x) {calculateEulerEquationDiff(\n              aggregateIncomeGridPoints[stateIndex],\n              storageGridPoints[storageIndex],\n              relativeParetoWeightsGridPoints[weightIndex],\n              returnOnStorage,\n              x,\n              aggregateIncomeGridPoints,\n              relativeParetoWeightsGridPoints,\n              nextStorageArray,\n              relativeParetoWeightsBoundsArray,\n              incomeTransitionMatrix[stateIndex,],\n              numStates,\n              sigma,\n              beta\n              )},\n            c(\n              0, \n              aggregateIncomeGridPoints[stateIndex] \n              + (1 + returnOnStorage) * storageGridPoints[storageIndex] \n              - 1e-12\n              )\n            )$root\n          valueArrayHH1New[stateIndex, weightIndex, storageIndex] <- calculateValue(\n            aggregateIncomeGridPoints[stateIndex],\n            storageGridPoints[storageIndex],\n            currentRelativeParetoWeight = relativeParetoWeightsGridPoints[weightIndex],\n            returnOnStorage,\n            nextPeriodStorage = nextStorageArrayNew[stateIndex, weightIndex, storageIndex],\n            relativeParetoWeightsGridPoints,\n            valueArrayHH1,\n            incomeTransitionProbVec,\n            numStates,\n            sigma,\n            beta,\n            calculateHH1Consumption\n            )\n          valueArrayHH2New[stateIndex, weightIndex, storageIndex] <- calculateValue(\n            aggregateIncomeGridPoints[stateIndex],\n            storageGridPoints[storageIndex],\n            currentRelativeParetoWeight = relativeParetoWeightsGridPoints[weightIndex],\n            returnOnStorage,\n            nextPeriodStorage = nextStorageArrayNew[stateIndex, weightIndex, storageIndex],\n            relativeParetoWeightsGridPoints,\n            valueArrayHH2,\n            incomeTransitionProbVec,\n            numStates,\n            sigma,\n            beta,\n            calculateHH2Consumption\n            )\n        }\n      }\n        \n      # Values and policies outside the interval\n      nextStorageArrayNew[\n        stateIndex,\n        relativeParetoWeightsGridPoints > relativeParetoWeightsUpper,\n        storageIndex\n      ] <- nextStorageArrayNew[\n        stateIndex,\n        relativeParetoWeightsUpperIndex,\n        storageIndex\n      ]\n      valueArrayHH1New[\n        stateIndex,\n        relativeParetoWeightsGridPoints > relativeParetoWeightsUpper,\n        storageIndex\n      ] <- valueArrayHH1New[\n        stateIndex,\n        relativeParetoWeightsUpperIndex,\n        storageIndex\n      ]\n      valueArrayHH2New[\n        stateIndex,\n        relativeParetoWeightsGridPoints > relativeParetoWeightsUpper,\n        storageIndex\n      ] <- valueArrayHH2New[\n        stateIndex,\n        relativeParetoWeightsUpperIndex,\n        storageIndex\n      ]\n      \n      nextStorageArrayNew[\n        stateIndex,\n        relativeParetoWeightsGridPoints < relativeParetoWeightsLower,\n        storageIndex\n      ] <- nextStorageArrayNew[\n        stateIndex,\n        relativeParetoWeightsLowerIndex,\n        storageIndex\n      ]\n      valueArrayHH1New[\n        stateIndex,\n        relativeParetoWeightsGridPoints < relativeParetoWeightsLower,\n        storageIndex\n      ] <- valueArrayHH1New[\n        stateIndex,\n        relativeParetoWeightsLowerIndex,\n        storageIndex\n      ]\n      valueArrayHH2New[\n        stateIndex,\n        relativeParetoWeightsGridPoints < relativeParetoWeightsLower,\n        storageIndex\n      ] <- valueArrayHH2New[\n        stateIndex,\n        relativeParetoWeightsLowerIndex,\n        storageIndex\n      ]\n    }\n    toc()\n    \n    nextStorageArrayNew[stateIndex,\n                     ,\n                     1] %>% plot\n  }\n  \n  diff <- max(c(\n    max(abs(valueArrayHH1New - valueArrayHH1)),\n    max(abs(valueArrayHH2New - valueArrayHH2))\n  ))\n  \n  relativeParetoWeightsBoundsArray <- relativeParetoWeightsBoundsArrayNew\n  nextStorageArray <- nextStorageArrayNew\n  valueArrayHH1 <- valueArrayHH1New\n  valueArrayHH2 <- valueArrayHH2New\n  iter <- iter + 1\n  print(diff)\n  print(iter)\n  \n  print(relativeParetoWeightsBoundsArray[1,,1])\n  print(relativeParetoWeightsBoundsArray[2,,1])\n  \n}\n\n\n# saveRDS(\n#   list(\n#     valueArrayHH1,\n#     valueArrayHH2,\n#     relativeParetoWeightsBoundsArray,\n#     nextStorageArray\n#   ),\n#   file.path('IntermediateData/modelSolution.rds')\n# )"
  },
  {
    "objectID": "lc_storage_simulation.html#storage-and-consumption-at-the-steady-state",
    "href": "lc_storage_simulation.html#storage-and-consumption-at-the-steady-state",
    "title": "3  Risk sharing with limited commitment and storage: Simulation",
    "section": "3.1 Storage and consumption at the steady state",
    "text": "3.1 Storage and consumption at the steady state\n\nsimulationResult %>% \n  filter(period >= 100) %>% \n  ggplot(aes(x = period, y = storage)) +\n  geom_point() +\n  xlab('Time period') +\n  ylab('Public storage') +\n  theme_classic()\n\n\n\nsimulationResult %>% \n  filter(period >= 100) %>% \n  ggplot(aes(x = period, y = consHH1)) +\n  geom_point() +\n  xlab('Time period') +\n  ylab('HH1 consumption') +\n  theme_classic()"
  },
  {
    "objectID": "lc_storage_simulation.html#relative-pareto-weight-intervals",
    "href": "lc_storage_simulation.html#relative-pareto-weight-intervals",
    "title": "3  Risk sharing with limited commitment and storage: Simulation",
    "section": "3.2 Relative Pareto weight intervals",
    "text": "3.2 Relative Pareto weight intervals\n\ntibble(\n  storage = storageGridPoints,\n  x_l_1 = relativeParetoWeightsBoundsArray[1,1,],\n  x_l_2 = relativeParetoWeightsBoundsArray[1,2,],\n  x_l_3 = relativeParetoWeightsBoundsArray[1,3,],\n  x_h_1 = relativeParetoWeightsBoundsArray[2,1,],\n  x_h_2 = relativeParetoWeightsBoundsArray[2,2,],\n  x_h_3 = relativeParetoWeightsBoundsArray[2,3,]\n) %>% \n  ggplot() +\n  geom_line(aes(x = storage, y = x_l_1, color = 'a')) +\n  geom_line(aes(x = storage, y = x_l_2, color = 'b')) +\n  geom_line(aes(x = storage, y = x_l_3, color = 'c')) +\n  geom_line(aes(x = storage, y = x_h_1, color = 'd')) +\n  geom_line(aes(x = storage, y = x_h_2, color = 'e')) +\n  geom_line(aes(x = storage, y = x_h_3, color = 'f')) +\n      scale_color_manual(\n      name = \"End-points\",\n      values = c(\n        \"blue\",\n        \"purple\",\n        \"brown\",\n        \"red\",\n        \"orange\",\n        \"gray\"\n        ),\n      labels = unname(TeX(c(\n        \"$\\\\underline{x}_1$\",\n        \"$\\\\underline{x}_2$\",\n        \"$\\\\underline{x}_3$\",\n        \"$\\\\bar{x}_1$\",\n        \"$\\\\bar{x}_2$\",\n        \"$\\\\bar{x}_3$\"\n        )))\n      ) +\n  theme_minimal() +\n  scale_y_log10() +\n  xlab('Public storage') + \n  ylab('Relative Pareto weight')"
  },
  {
    "objectID": "lc_storage_simulation.html#storage-behavior",
    "href": "lc_storage_simulation.html#storage-behavior",
    "title": "3  Risk sharing with limited commitment and storage: Simulation",
    "section": "3.3 Storage behavior",
    "text": "3.3 Storage behavior\n\ntibble(\n  storage = storageGridPoints,\n  x1 = nextStorageArray[1,101,],\n  x2 = nextStorageArray[2,101,],\n  x3 = nextStorageArray[3,101,],\n) %>% \n  filter(storageGridPoints < 0.05) %>% \n  ggplot() +\n  geom_line(aes(x = storage, y = x1, color = 'a')) +\n  geom_line(aes(x = storage, y = x2, color = 'b')) +\n  geom_line(aes(x = storage, y = x3, color = 'c'))\n\n\n\ntibble(\n  storage = storageGridPoints,\n  x1 = nextStorageArray[1,51,],\n  x2 = nextStorageArray[2,51,],\n  x3 = nextStorageArray[3,51,],\n) %>% \n  filter(storageGridPoints < 0.05) %>% \n  ggplot() +\n  geom_line(aes(x = storage, y = x1, color = 'a')) +\n  geom_line(aes(x = storage, y = x2, color = 'b')) +\n  geom_line(aes(x = storage, y = x3, color = 'c'))\n\n\n\n## Transition in storage\n\n\nsimulationResult %>% \n  filter(period >= 100) %>% \n  mutate(cond = (income == 2)) %>% \n  ggplot() +\n  geom_point(aes(x = period, y = storage, color = changeIncome), size = 1.0) +\n  xlab('Time period') +\n  ylab('Public storage') +\n  theme_classic()\n\n\n\n\n\n3.3.1 No income inequality state\n\nsimulationResult %>% \n  filter(period >= 100) %>% \n  mutate(cond = (income == 2)) %>% \n  mutate(alpha = 1 * cond + 0.01 * (!cond)) %>% \n  ggplot() +\n  geom_point(aes(x = period, y = storage, color = changeIncome, alpha = alpha), size = 0.3) +\n  scale_alpha(guide = \"none\") +\n  xlab('Time period') +\n  ylab('Public storage') +\n  theme_classic()\n\n\n\n\n\n\n3.3.2 From no income inequality to some inequality\n\nsimulationResult %>% \n  filter(period >= 100) %>% \n  mutate(cond = (income != 2 & previousIncome == 2)) %>% \n  mutate(alpha = 1 * cond + 0.2 * (!cond)) %>% \n  ggplot() +\n  geom_point(aes(x = period, y = storage, color = changeIncome, alpha = alpha), size = 0.3) +\n  scale_alpha(guide = \"none\") +\n  xlab('Time period') +\n  ylab('Public storage') +\n  theme_classic()\n\n\n\n\n\n\n3.3.3 Consecutvive states with some income inequality\n\nsimulationResult %>% \n  filter(period >= 100) %>% \n  mutate(cond = (income != 2 & previousIncome != 2)) %>% \n  mutate(alpha = 1 * cond + 0.2 * (!cond)) %>% \n  ggplot() +\n  geom_point(aes(x = period, y = storage, color = changeIncome, alpha = alpha), size = 0.3) +\n  scale_alpha(guide = \"none\") +\n  xlab('Time period') +\n  ylab('Public storage') +\n  theme_classic()\n\n\n\n\n\n# saveRDS(\n#   simulationResult,\n#   file.path('IntermediateData/simulationResult.rds')\n# )\n\n```"
  },
  {
    "objectID": "lc_no_storage.html#code",
    "href": "lc_no_storage.html#code",
    "title": "4  Comparison: Risk sharing with limited commitment but without storage",
    "section": "4.1 Code",
    "text": "4.1 Code\n\npacman::p_load(\n  tidyverse,\n  kableExtra,\n  latex2exp\n)\n\n\n4.1.1 Utility functions\n\ncalculateUtility <- function(cons, sigma) {\n  if (sigma != 1) {\n    utility = (cons^(1 - sigma) - 1) / (1 - sigma)\n  } else if (sigma == 1) {\n    utility = log(cons)\n  }\n  return(utility)\n}\ncalculateMarginalUtility <- function(cons, sigma) cons^(- sigma)\n\n\n\n4.1.2 Consumption function\n\ncalculateHH1Consumption <- function(\n  aggregateResources,\n  relativeParetoWeight,\n  sigma\n) {\n    aggregateResources / (1 + (relativeParetoWeight^(1 / sigma)))\n}\n\n\n\n4.1.3 Value under autarky\n\ncalculateAutarkyValue <- function(\n    incomeGridPoints, \n    sigma,\n    delta,\n    punishment,\n    incomeTransitionMatrix\n) {\n  \n  autarkyValue <- numeric(length = length(incomeGridPoints))\n  i <- 1\n  diff <- 1\n  while (diff > 1e-12) {\n    autarkyValueNew <- (\n      calculateUtility(incomeGridPoints * (1 - punishment), sigma) \n      + delta * incomeTransitionMatrix %*% autarkyValue\n    )\n    diff <- max(abs(autarkyValueNew - autarkyValue))\n    autarkyValue <- autarkyValueNew\n    i <- i + 1\n  }\n  return(autarkyValue)\n}\n\n\ngetRelativeParetoWeightsGridPoints <- function(\n    sigma,\n    punishment,\n    householdIncomeGridPoints,\n    villageIncomeGridPoints,\n    numRelativeParetoWeights\n    ) {\n  \n  minRelativeParetoWeights <- (\n    calculateMarginalUtility(max(villageIncomeGridPoints), sigma) \n    / calculateMarginalUtility(min(householdIncomeGridPoints * (1 - punishment)), sigma)\n  )\n  maxRelativeParetoWeights <- (\n    calculateMarginalUtility(min(villageIncomeGridPoints * (1 - punishment)), sigma) \n    / calculateMarginalUtility(max(householdIncomeGridPoints), sigma)\n  )\n  relativeParetoWeightsGridPoints <- exp(\n    seq(\n      log(minRelativeParetoWeights), \n      log(maxRelativeParetoWeights), \n      length.out = numRelativeParetoWeights)\n    )\n  return(relativeParetoWeightsGridPoints)\n}\n\n\ncalculateHouseholdConsumption <- function(\n  aggregateIncome,\n  relativeParetoWeight,\n  numHouseholds,\n  sigma\n) {\n    aggregateIncome / (1 + (numHouseholds - 1) * (relativeParetoWeight^(- 1 / sigma)))\n}\n\n\ncalculateValueFullRiskSharing <- function(\n  incomeTransitionMatrix, \n  aggregateIncomeGridPoints, \n  delta, \n  sigma, \n  autarkyValueMatrix, \n  consumptionOnRelativeParetoWeightGrid,\n  numRelativeParetoWeights,\n  numHouseholds\n  ) {\n\n  # Initial guess is expected utilities under autarky\n  householdValueFullRiskSharing <- outer(\n    autarkyValueMatrix[, 1], rep(1, numRelativeParetoWeights)\n    )\n  villageValueFullRiskSharing <- outer(\n    autarkyValueMatrix[, 2], rep(1, numRelativeParetoWeights)\n    )\n\n  iteration <- 1\n  diff <- 1\n  while (diff > 1e-10 & iteration < 500) {\n    householdValueFullRiskSharingNew <- (\n      calculateUtility(consumptionOnRelativeParetoWeightGrid, sigma) \n      + delta * incomeTransitionMatrix %*% householdValueFullRiskSharing\n    )\n    villageValueFullRiskSharingNew <- (\n      calculateUtility(\n        (aggregateIncomeGridPoints - consumptionOnRelativeParetoWeightGrid) / (numHouseholds - 1), \n        sigma\n        ) \n      + delta * incomeTransitionMatrix %*% villageValueFullRiskSharing\n    )\n    \n    diff <- max(\n      max(abs(householdValueFullRiskSharing - householdValueFullRiskSharingNew)), \n      max(abs(villageValueFullRiskSharing - villageValueFullRiskSharingNew))\n      )\n    householdValueFullRiskSharing <- householdValueFullRiskSharingNew\n    villageValueFullRiskSharing <- villageValueFullRiskSharingNew\n    iteration <- iteration + 1\n    \n  }\n\n  return(list(\n    householdValueFullRiskSharing = householdValueFullRiskSharing, \n    villageValueFullRiskSharing = villageValueFullRiskSharing\n    ))\n}\n\n\ninterpolateValueFunction <- function(\n    relativeParetoWeight,\n    relativeParetoWeightsGridPoints,\n    valueFunctionMatrix\n    ) {\n  apply(\n    valueFunctionMatrix,\n    1,\n    function(x) {\n      approx(\n        relativeParetoWeightsGridPoints, \n        x, \n        relativeParetoWeight,\n        rule = 2\n        )$y\n    }\n    )\n}\n\ncalculateDiffLCRiskSharingAndAutarky <- function(\n    relativeParetoWeight,\n    relativeParetoWeightsGridPoints,\n    delta,\n    sigma,\n    aggregateIncome,\n    householdValueLCRiskSharing,\n    villageValueLCRiskSharing,\n    incomeTransitionProbVec,\n    householdAutarkyValue,\n    villageAutarkyValue,\n    numHouseholds\n    ) {\n  \n  householdConsumption <- calculateHouseholdConsumption(\n    aggregateIncome,\n    relativeParetoWeight,\n    numHouseholds,\n    sigma\n  )\n  \n  householdValueLCRiskSharingAtRelativeParetoWeight <- interpolateValueFunction(\n    relativeParetoWeight,\n    relativeParetoWeightsGridPoints,\n    householdValueLCRiskSharing\n    )\n  villageValueLCRiskSharingAtRelativeParetoWeight <- interpolateValueFunction(\n    relativeParetoWeight,\n    relativeParetoWeightsGridPoints,\n    villageValueLCRiskSharing\n    )\n  \n  householdDiffLCRiskSharingAndAutarky <- (\n    calculateUtility(householdConsumption, sigma) \n    + delta * incomeTransitionProbVec %*% householdValueLCRiskSharingAtRelativeParetoWeight \n    - householdAutarkyValue\n  ) %>% as.numeric\n  villageDiffLCRiskSharingAndAutarky <- (\n    calculateUtility((aggregateIncome - householdConsumption) / (numHouseholds - 1), sigma) \n    + delta * incomeTransitionProbVec %*% villageValueLCRiskSharingAtRelativeParetoWeight \n    - villageAutarkyValue\n  ) %>% as.numeric\n\n  return(list(\n    householdDiffLCRiskSharingAndAutarky = householdDiffLCRiskSharingAndAutarky,\n    villageDiffLCRiskSharingAndAutarky = villageDiffLCRiskSharingAndAutarky\n  ))\n}\n\n\ncalculateValueLCRiskSharing <- function(\n  valueFullRiskSharing,\n  consumptionOnRelativeParetoWeightGrid,\n  aggregateIncomeGridPoints,\n  incomeTransitionMatrix,\n  autarkyValueMatrix,\n  relativeParetoWeightsGridPoints,\n  numRelativeParetoWeights,\n  delta,\n  sigma,\n  numIncomeStates,\n  numHouseholds,\n  iterationLimit,\n  diffLimit\n) {\n  \n  # Initial guess is expected utilities under full risk sharing\n  householdValueLCRiskSharing <- valueFullRiskSharing$householdValueFullRiskSharing\n  villageValueLCRiskSharing <- valueFullRiskSharing$villageValueFullRiskSharing\n  \n  diff <- 1\n  iteration <- 1\n  while ((diff > diffLimit) && (iteration <= iterationLimit)) {\n    \n    # First, ignore enforceability and just update the value functions\n    # using the values at the previous iteration\n    householdValueLCRiskSharingNew <- (\n      calculateUtility(consumptionOnRelativeParetoWeightGrid, sigma) \n      + delta * incomeTransitionMatrix %*% householdValueLCRiskSharing\n    )\n    villageValueLCRiskSharingNew <- (\n      calculateUtility(\n        (aggregateIncomeGridPoints - consumptionOnRelativeParetoWeightGrid) / (numHouseholds - 1), \n        sigma\n        )\n      + delta * incomeTransitionMatrix %*% villageValueLCRiskSharing\n    )\n    \n    # Now check enforceability at each state\n    for (incomeStateIndex in seq(1, numIncomeStates)) {\n      householdAutarkyValue <- autarkyValueMatrix[incomeStateIndex, 1]\n      villageAutarkyValue <- autarkyValueMatrix[incomeStateIndex, 2]\n      \n      if (any(householdValueLCRiskSharingNew[incomeStateIndex, ] <= householdAutarkyValue)) {\n        villageValueLCRiskSharingNew[\n          incomeStateIndex,\n          householdValueLCRiskSharingNew[incomeStateIndex, ] <= householdAutarkyValue\n        ] <- villageValueLCRiskSharingNew[\n          incomeStateIndex,\n          householdValueLCRiskSharingNew[incomeStateIndex, ] <= householdAutarkyValue\n        ] %>% min\n        householdValueLCRiskSharingNew[\n          incomeStateIndex,\n          householdValueLCRiskSharingNew[incomeStateIndex, ] <= householdAutarkyValue\n        ] <- householdAutarkyValue\n      }\n      \n      if (any(villageValueLCRiskSharingNew[incomeStateIndex, ] <= villageAutarkyValue)) {\n        householdValueLCRiskSharingNew[\n          incomeStateIndex,\n          villageValueLCRiskSharingNew[incomeStateIndex, ] <= villageAutarkyValue\n        ] <- householdValueLCRiskSharingNew[\n          incomeStateIndex,\n          villageValueLCRiskSharingNew[incomeStateIndex, ] <= villageAutarkyValue\n        ] %>% min\n        villageValueLCRiskSharingNew[\n          incomeStateIndex,\n          villageValueLCRiskSharingNew[incomeStateIndex, ] <= villageAutarkyValue\n        ] <- villageAutarkyValue\n      }\n    }\n      \n    diff <- max(\n      max(abs(householdValueLCRiskSharingNew - householdValueLCRiskSharing)),\n      max(abs(villageValueLCRiskSharingNew - villageValueLCRiskSharing))\n    )\n    householdValueLCRiskSharing <- householdValueLCRiskSharingNew\n    villageValueLCRiskSharing <- villageValueLCRiskSharingNew\n    iteration <- iteration + 1\n  }\n  \n  relativeParetoWeightBounds <- matrix(NA, nrow = numIncomeStates, ncol = 2)\n  \n  for (incomeStateIndex in seq(1, numIncomeStates)) {\n    aggregateIncome <- aggregateIncomeGridPoints[incomeStateIndex]\n    incomeTransitionProbVec <- incomeTransitionMatrix[incomeStateIndex,]\n    householdAutarkyValue <- autarkyValueMatrix[incomeStateIndex, 1]\n    villageAutarkyValue <- autarkyValueMatrix[incomeStateIndex, 2]\n\n    if (\n      calculateDiffLCRiskSharingAndAutarky(\n        min(relativeParetoWeightsGridPoints),\n        relativeParetoWeightsGridPoints,\n        delta,\n        sigma,\n        aggregateIncome,\n        householdValueLCRiskSharing,\n        villageValueLCRiskSharing,\n        incomeTransitionProbVec,\n        householdAutarkyValue,\n        villageAutarkyValue,\n        numHouseholds\n        )$householdDiffLCRiskSharingAndAutarky < 0) {\n        relativeParetoWeightLowerBound <- uniroot(\n          function(x) {calculateDiffLCRiskSharingAndAutarky(\n          x,\n          relativeParetoWeightsGridPoints,\n          delta,\n          sigma,\n          aggregateIncome,\n          householdValueLCRiskSharing,\n          villageValueLCRiskSharing,\n          incomeTransitionProbVec,\n          householdAutarkyValue,\n          villageAutarkyValue,\n          numHouseholds\n          )$householdDiffLCRiskSharingAndAutarky}, \n        c(min(relativeParetoWeightsGridPoints), max(relativeParetoWeightsGridPoints)), \n        tol = 1e-10, \n        maxiter = 300\n        )$root\n        } else {\n          relativeParetoWeightLowerBound <- min(relativeParetoWeightsGridPoints)\n        }\n    \n    if (\n      calculateDiffLCRiskSharingAndAutarky(\n        max(relativeParetoWeightsGridPoints),\n        relativeParetoWeightsGridPoints,\n        delta,\n        sigma,\n        aggregateIncome,\n        householdValueLCRiskSharing,\n        villageValueLCRiskSharing,\n        incomeTransitionProbVec,\n        householdAutarkyValue,\n        villageAutarkyValue,\n        numHouseholds\n        )$villageDiffLCRiskSharingAndAutarky < 0) {\n        relativeParetoWeightUpperBound <- uniroot(\n          function(x) {calculateDiffLCRiskSharingAndAutarky(\n          x,\n          relativeParetoWeightsGridPoints,\n          delta,\n          sigma,\n          aggregateIncome,\n          householdValueLCRiskSharing,\n          villageValueLCRiskSharing,\n          incomeTransitionProbVec,\n          householdAutarkyValue,\n          villageAutarkyValue,\n          numHouseholds\n          )$villageDiffLCRiskSharingAndAutarky}, \n        c(min(relativeParetoWeightsGridPoints), max(relativeParetoWeightsGridPoints)), \n        tol = 1e-10, \n        maxiter = 300\n        )$root\n        } else {\n          relativeParetoWeightUpperBound <- max(relativeParetoWeightsGridPoints)\n        }\n        relativeParetoWeightBounds[incomeStateIndex, 1] <- relativeParetoWeightLowerBound\n        relativeParetoWeightBounds[incomeStateIndex, 2] <- relativeParetoWeightUpperBound\n        }\n\n  if (iteration == iterationLimit) {\n    print(\"Reached the maximum limit of iterations!\")\n  }\n  \n  return(list(\n    householdValueLCRiskSharing = householdValueLCRiskSharing,\n    villageValueLCRiskSharing = villageValueLCRiskSharing,\n    relativeParetoWeightBounds = relativeParetoWeightBounds))\n}\n\n\nsolveLCRiskSharing <- function(\n    delta,\n    sigma,\n    punishment,\n    householdIncomeGridPoints,\n    villageIncomeGridPoints,\n    incomeTransitionMatrix,\n    incomeGridPointsMatrix,\n    numIncomeStates,\n    numHouseholds,\n    numRelativeParetoWeights = 2000,\n    iterationLimit = 100,\n    diffLimit = 1e-8\n) {\n  \n  aggregateIncomeGridPoints <- (\n    incomeGridPointsMatrix[, 1] + incomeGridPointsMatrix[, 2] * (numHouseholds - 1)\n  )\n  \n  autarkyValueMatrix <- cbind(\n    calculateAutarkyValue(\n      householdIncomeGridPoints,\n      sigma,\n      delta,\n      punishment,\n      incomeTransitionMatrix\n    ),\n    calculateAutarkyValue(\n      villageIncomeGridPoints,\n      sigma,\n      delta,\n      punishment,\n      incomeTransitionMatrix\n    )\n  )\n  \n  relativeParetoWeightsGridPoints <- getRelativeParetoWeightsGridPoints(\n      sigma,\n      punishment,\n      householdIncomeGridPoints,\n      villageIncomeGridPoints,\n      numRelativeParetoWeights\n      )\n  \n  consumptionOnRelativeParetoWeightGrid <- matrix(\n    NA, nrow = numIncomeStates, ncol = numRelativeParetoWeights\n    )\n  for (incomeStateIndex in seq_along(aggregateIncomeGridPoints)) {\n    for (relativeParetoWeightIndex in seq_along(relativeParetoWeightsGridPoints)) {\n      consumptionOnRelativeParetoWeightGrid[\n        incomeStateIndex, \n        relativeParetoWeightIndex\n        ] <- calculateHouseholdConsumption(\n          aggregateIncomeGridPoints[incomeStateIndex],\n          relativeParetoWeightsGridPoints[relativeParetoWeightIndex],\n          numHouseholds,\n          sigma\n        )\n      }\n    }\n\n  valueFullRiskSharing <- calculateValueFullRiskSharing(\n    incomeTransitionMatrix, \n    aggregateIncomeGridPoints, \n    delta, \n    sigma, \n    autarkyValueMatrix, \n    consumptionOnRelativeParetoWeightGrid,\n    numRelativeParetoWeights,\n    numHouseholds\n    )\n\n  valueLCRiskSharing <- calculateValueLCRiskSharing(\n    valueFullRiskSharing,\n    consumptionOnRelativeParetoWeightGrid,\n    aggregateIncomeGridPoints,\n    incomeTransitionMatrix,\n    autarkyValueMatrix,\n    relativeParetoWeightsGridPoints,\n    numRelativeParetoWeights,\n    delta,\n    sigma,\n    numIncomeStates,\n    numHouseholds,\n    iterationLimit,\n    diffLimit\n  )\n\n  return(valueLCRiskSharing)\n}\n\n\nsigma <- 1.0\npunishment <- 0.0\n\ndelta <- 0.8\nsigma <- 1\nnumHouseholds <- 2\nnumIncomeStates <- 3\n\nincomeGridPointsHH1 <- c(0.353, 0.5, 0.647)\nincomeGridPointsHH2 <- 1 - incomeGridPointsHH1\nincomeGridPointsMatrix <- cbind(incomeGridPointsHH1, incomeGridPointsHH2)\naggregateIncomeGridPoints <- incomeGridPointsHH1 + incomeGridPointsHH2\n\nincomeTransitionMatrix <- matrix(1 / 3, nrow = 3, ncol = 3)\n\n\nLCRiskSharingNoStorageResult <- solveLCRiskSharing(\n    delta,\n    sigma,\n    punishment,\n    incomeGridPointsHH1,\n    incomeGridPointsHH2,\n    incomeTransitionMatrix,\n    incomeGridPointsMatrix,\n    numIncomeStates,\n    numHouseholds,\n    numRelativeParetoWeights = 10000,\n    iterationLimit = 1000,\n    diffLimit = 1e-8\n    )\n\n\nset.seed(123)\nsimSize <- 5000\nincomeSeq <- sample(seq(1, numIncomeStates), size = simSize, replace = TRUE)\n\nrelativeParetoWeightSeqNoStorage <- c(1)\nconsHH1SeqNoStorage <- c()\n\nfor (i in seq(1, simSize)) {\n  relativeParetoWeightSeqNoStorage <- c(\n    relativeParetoWeightSeqNoStorage,\n    relativeParetoWeightSeqNoStorage[i] %>% \n      pmax(\n        LCRiskSharingNoStorageResult$relativeParetoWeightBounds[\n          incomeSeq[i],\n          1\n        ]\n      ) %>% \n      pmin(\n        LCRiskSharingNoStorageResult$relativeParetoWeightBounds[\n          incomeSeq[i],\n          2\n        ]\n      )\n  )\n  \n  consHH1SeqNoStorage <- c(\n    consHH1SeqNoStorage,\n    calculateHH1Consumption(\n      (aggregateIncomeGridPoints[incomeSeq[i]]),\n      relativeParetoWeightSeqNoStorage[i + 1],\n      sigma\n    )\n  )\n}\n\nsimulationResultNoStorage <- tibble(\n  period = seq(1, simSize),\n  income = incomeSeq,\n  consHH1 = consHH1SeqNoStorage\n) %>% \n  mutate(\n    previousIncome = lag(income),\n    changeIncome = paste(as.character(previousIncome), '->', as.character(income))\n    )\n\n\nsimulationResultNoStorage %>% \n  filter(period >= 100) %>% \n  ggplot() +\n  geom_point(aes(x = period, y = consHH1), size = 0.3) +\n  xlab('Time period') +\n  ylab('HH1 consumption') +\n  theme_classic()"
  },
  {
    "objectID": "lc_no_storage.html#comparison-with-the-case-with-storage",
    "href": "lc_no_storage.html#comparison-with-the-case-with-storage",
    "title": "4  Comparison: Risk sharing with limited commitment but without storage",
    "section": "4.2 Comparison with the case with storage",
    "text": "4.2 Comparison with the case with storage\n\nsimulationResult <- readRDS(\n  file.path('IntermediateData/simulationResult.rds')\n)\n\n\nsummaryTable <- cbind(\n  c(\n    (simulationResult %>% filter(period >= 100) %>% .$consHH1) %>% mean,\n    (simulationResult %>% filter(period >= 100) %>% .$consHH1) %>% sd,\n    log(simulationResult %>% filter(period >= 100) %>% .$consHH1) %>% mean\n  ),\n  c(\n    (simulationResultNoStorage %>% filter(period >= 100) %>% .$consHH1) %>% mean,\n    (simulationResultNoStorage %>% filter(period >= 100) %>% .$consHH1) %>% sd,\n    log(simulationResultNoStorage %>% filter(period >= 100) %>% .$consHH1) %>% mean\n  )\n) \n\nrownames(summaryTable) <- c(\"Mean Cons.\", \"SD Cons\", \"Mean Util.\")\ncolnames(summaryTable) <- c(\"With storage\", \"Without storage\")\n\nsummaryTable %>% \n  kbl(digits = 4) %>% \n  kable_classic()\n\n\n\n \n  \n      \n    With storage \n    Without storage \n  \n \n\n  \n    Mean Cons. \n    0.5009 \n    0.4992 \n  \n  \n    SD Cons \n    0.0863 \n    0.0717 \n  \n  \n    Mean Util. \n    -0.7067 \n    -0.7053"
  },
  {
    "objectID": "lc_no_storage.html#references",
    "href": "lc_no_storage.html#references",
    "title": "4  Comparison: Risk sharing with limited commitment but without storage",
    "section": "4.3 References",
    "text": "4.3 References"
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "Risk-sharing with limited commitment and storage",
    "section": "References",
    "text": "References\n\n\n\n\nÁbrahám, Árpád, and Sarolta Laczó. 2018. “Efficient Risk Sharing with Limited Commitment and Storage.” The Review of Economic Studies 85 (3): 1389–1424.\n\n\nLigon, Ethan, Jonathan P. Thomas, and Tim Worrall. 2002. “Informal Insurance Arrangements with Limited Commitment: Theory and Evidence from Village Economies.” Review of Economic Studies 69 (1): 209–44. https://doi.org/10.1111/1467-937X.00204."
  },
  {
    "objectID": "lc_storage_model.html#transition-of-the-states",
    "href": "lc_storage_model.html#transition-of-the-states",
    "title": "1  Risk sharing with limited commitment and storage: Model",
    "section": "1.2 Transition of the states",
    "text": "1.2 Transition of the states\nFirst I review the solutions (policy functions and value functions) of the model and see how the states evolve in the model. In this document, I define the relative Pareto weight, x, as x \\equiv \\frac{u'(c_1)}{u'(c_2)}, which implies that higher x is in favor of Household 2. For policy functions, I consider x'(y, B, x), a current relative Pareto weight, B'(y, B, x), a next-period storage, and (\\underline{x}(y, B), \\overline{x}(y, B)), a interval specific to a state-storage pair. Note that \n  x'(y, B, x) = \\begin{cases}\n    \\overline{x}(y, B) \\quad &\\text{if } x \\ge \\overline{x}(y, B) \\\\\n    x \\quad &\\text{if } x \\in (\\underline{x}(y, B), \\overline{x}(y, B)) \\\\\n    \\underline{x}(y, B) \\quad &\\text{if } x \\le \\underline{x}(y, B).\n  \\end{cases}\n Individual value functions are denoted as V_1(y, B, x) and V_2(y, B, x).\nBy the intratemporal optimality conditions \n\\begin{aligned}\n  c_1(y, B, x) &= \\frac{y + (1 + r)B - B'(y, B, x)}{1 + x'(y, B, x)} \\\\\n  c_2(y, B, x) &= \\frac{y + (1 + r)B - B'(y, B, x)}{1 + 1 / x'(y, B, x)},\n\\end{aligned}\n and \n  \\nu_1(y, B, x) = \\max \\left\\{ 1 - \\frac{x'(y, B, x)}{x}, 0 \\right\\}.\n Note that \\nu_1 is not 0 when participation constraint of Household 1 binds.\nFor each (y, B), consider the following cases:\n\n1.2.1 Case 1: x < \\underline{x}(y, B)\nBy the update rule of the relative Pareto weight, x' = \\underline{x}(y, B). Since the participation constraint of Household 2 is binding, \n  u(c_2(y, B, x)) + \\beta \\sum_{y'} Pr(y') V_2(y', B'(y, B, x), \\underline{x}) = U_2^{aut}(y) \\quad \\left( = V_2(y, B, x) \\right),\n and the planner’s Euler equation is \n  u'(c_1(y, B, x)) \\ge \\beta (1 + r) \\sum_{y'} Pr(y') \\frac{u'(c_1(y', B'(y, B, x), \\underline{x}(y, B)))}{1 - \\nu_1(y', B'(y, B, x), \\underline{x}(y, B))}.\n Note that, in this case, B'(y, B, x) does not depend on x: if you look at the binding participation constraint of Household 2, since x is updated to \\underline{x}(y, B), the consumption c_2 does not depend on x, and since the right-hand side of the equation does not depend on x, the value function term should not depend on x either. Or, an alternative way to argue this is to refer to Lemma 1 of Ábrahám and Laczó (2018) stating that the current x is a sufficient statistic for B', given B (and actually y too because I consider a more general case that the aggregate income can differ across states).\nThe value function of Household 1 is \n  V_1(y, B, x) = u(c_1(y, B, x)) + \\beta \\sum_{y'} Pr(y') V_1(y', B'(y, B, x), \\underline{x}(y, B)).\n Notice that this also does not depend on x since c_1 and B' do not depend on x.\n\n\n1.2.2 Case 2: x = \\underline{x}(y, B)\nBy the update rule of the relative Pareto weight, x' = \\underline{x}(y, B). Since the participation constraint of Household 2 is binding, \n  u(c_2(y, B, \\underline{x}(y, B))) + \\beta \\sum_{y'} Pr(y') V_2(y', B'(y, B, \\underline{x}(y, B)), \\underline{x}) = U_2^{aut}(y) \\quad \\left( = V_2(y, B, \\underline{x}(y, B)) \\right),\n and the planner’s Euler equation is \n  u'(c_1(y, B, \\underline{x}(y, B))) \\ge \\beta (1 + r) \\sum_{y'} Pr(y') \\frac{u'(c_1(y', B'(y, B, \\underline{x}(y, B)), \\underline{x}(y, B)))}{1 - \\nu_1(y', B'(y, B, \\underline{x}(y, B)), \\underline{x}(y, B))}.\n The value function of Household 1 is \n  V_1(y, B, \\underline{x}(y, B)) = u(c_1(y, B, \\underline{x}(y, B))) + \\beta \\sum_{y'} Pr(y') V_1(y', B'(y, B, \\underline{x}(y, B)), \\underline{x}(y, B)).\n\n\n\n1.2.3 Case 3: x \\in (\\underline{x}(y, B), \\overline{x}(y, B)\nSince no participation constraint is binding in this case, x' = x. Therefore, the value functions of the households are \n\\begin{aligned}\n  V_1(y, B, x) &= u(c_1(y, B, x)) + \\beta \\sum_{y'} Pr(y') V_1(y', B'(y, B, x), x) \\\\\n  V_2(y, B, x) &= u(c_2(y, B, x)) + \\beta \\sum_{y'} Pr(y') V_2(y', B'(y, B, x), x).\n\\end{aligned}\n And the planner’s Euler equation needs to be satisfied: \n  u'(c_1(y, B, x)) \\ge \\beta (1 + r) \\sum_{y'} Pr(y') \\frac{u'(c_1(y', B'(y, B, x), x))}{1 - \\nu_1(y', B'(y, B, x), x)}.\n\n\n\n1.2.4 Case 4: x = \\overline{x}(y, B)\nBy the update rule of the relative Pareto weight, x' = \\overline{x}(y, B). Since the participation constraint of Household 1 is binding, \n  u(c_1(y, B, \\overline{x}(y, B))) + \\beta \\sum_{y'} Pr(y') V_1(y', B'(y, B, \\overline{x}(y, B)), \\overline{x}) = U_1^{aut}(y) \\quad \\left( = V_1(y, B, \\overline{x}(y, B)) \\right),\n and the planner’s Euler equation is \n  u'(c_1(y, B, \\overline{x}(y, B))) \\ge \\beta (1 + r) \\sum_{y'} Pr(y') \\frac{u'(c_1(y', B'(y, B, \\overline{x}(y, B)), \\overline{x}(y, B)))}{1 - \\nu_1(y', B'(y, B, \\overline{x}(y, B)), \\overline{x}(y, B))}.\n The value function of Household 2 is \n  V_2(y, B, \\overline{x}(y, B)) = u(c_2(y, B, \\overline{x}(y, B))) + \\beta \\sum_{y'} Pr(y') V_2(y', B'(y, B, \\overline{x}(y, B)), \\overline{x}(y, B)).\n ### Case 5: x < \\overline{x}(y, B)\nBy the update rule of the relative Pareto weight, x' = \\overline{x}(y, B). Since the participation constraint of Household 1 is binding, \n  u(c_1(y, B, x)) + \\beta \\sum_{y'} Pr(y') V_1(y', B'(y, B, x), \\overline{x}) = U_1^{aut}(y) \\quad \\left( = V_1(y, B, x) \\right),\n and the planner’s Euler equation is \n  u'(c_1(y, B, x)) \\ge \\beta (1 + r) \\sum_{y'} Pr(y') \\frac{u'(c_1(y', B'(y, B, x), \\overline{x}(y, B)))}{1 - \\nu_1(y', B'(y, B, x), \\overline{x}(y, B))}.\n The value function of Household 2 is \n  V_2(y, B, x) = u(c_2(y, B, x)) + \\beta \\sum_{y'} Pr(y') V_2(y', B'(y, B, x), \\overline{x}(y, B)).\n As in Case 1, B', V_1, and V_2 do not depend on x."
  },
  {
    "objectID": "lc_storage_model.html#references",
    "href": "lc_storage_model.html#references",
    "title": "1  Risk sharing with limited commitment and storage: Model",
    "section": "1.3 References",
    "text": "1.3 References\n\n\n\n\nÁbrahám, Árpád, and Sarolta Laczó. 2018. “Efficient Risk Sharing with Limited Commitment and Storage.” The Review of Economic Studies 85 (3): 1389–1424."
  }
]